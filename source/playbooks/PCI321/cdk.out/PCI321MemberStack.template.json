{
 "Description": "(SO0111C) AWS Security Hub Automated Response & Remediation PCI 3.2.1 Compliance Pack - Member Account, v1.50.mybuild",
 "AWSTemplateFormatVersion": "2010-09-09",
 "Parameters": {
  "SecHubAdminAccount": {
   "Type": "String",
   "AllowedPattern": "\\d{12}",
   "Description": "Admin account number"
  },
  "EnablePCIAutoScaling1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.AutoScaling.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIIAM7": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.IAM.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCICloudTrail2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCICodeBuild2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CodeBuild.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCICW1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CW.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIEC21": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIEC22": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIEC25": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIIAM8": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.IAM.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIKMS1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.KMS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCILambda1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.Lambda.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIRDS1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.RDS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIRDS2": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.RDS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIRedshift1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.Redshift.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCICloudTrail1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIEC26": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCICloudTrail3": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCICloudTrail4": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIConfig1": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.Config.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIS31": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIS34": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIS35": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "EnablePCIS36": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  }
 },
 "Conditions": {
  "EnablePCIAutoScaling1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIAutoScaling1"
    },
    "Available"
   ]
  },
  "EnablePCIIAM7Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIIAM7"
    },
    "Available"
   ]
  },
  "EnablePCICloudTrail2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCICloudTrail2"
    },
    "Available"
   ]
  },
  "EnablePCICodeBuild2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCICodeBuild2"
    },
    "Available"
   ]
  },
  "EnablePCICW1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCICW1"
    },
    "Available"
   ]
  },
  "EnablePCIEC21Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIEC21"
    },
    "Available"
   ]
  },
  "EnablePCIEC22Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIEC22"
    },
    "Available"
   ]
  },
  "EnablePCIEC25Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIEC25"
    },
    "Available"
   ]
  },
  "EnablePCIIAM8Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIIAM8"
    },
    "Available"
   ]
  },
  "EnablePCIKMS1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIKMS1"
    },
    "Available"
   ]
  },
  "EnablePCILambda1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCILambda1"
    },
    "Available"
   ]
  },
  "EnablePCIRDS1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIRDS1"
    },
    "Available"
   ]
  },
  "EnablePCIRDS2Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIRDS2"
    },
    "Available"
   ]
  },
  "EnablePCIRedshift1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIRedshift1"
    },
    "Available"
   ]
  },
  "EnablePCICloudTrail1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCICloudTrail1"
    },
    "Available"
   ]
  },
  "EnablePCIEC26Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIEC26"
    },
    "Available"
   ]
  },
  "EnablePCICloudTrail3Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCICloudTrail3"
    },
    "Available"
   ]
  },
  "EnablePCICloudTrail4Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCICloudTrail4"
    },
    "Available"
   ]
  },
  "EnablePCIConfig1Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIConfig1"
    },
    "Available"
   ]
  },
  "EnablePCIS31Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIS31"
    },
    "Available"
   ]
  },
  "EnablePCIS34Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIS34"
    },
    "Available"
   ]
  },
  "EnablePCIS35Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIS35"
    },
    "Available"
   ]
  },
  "EnablePCIS36Condition": {
   "Fn::Equals": [
    {
     "Ref": "EnablePCIS36"
    },
    "Available"
   ]
  }
 },
 "Resources": {
  "PCIPCIAutoScaling1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.AutoScaling.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_PCI.AutoScaling.1\n\n  ## What does this document do?\n  This document enables ELB healthcheck on a given AutoScaling Group using the [UpdateAutoScalingGroup] API.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * HealthCheckGracePeriod: (Optional) Health check grace period when ELB health check is Enabled\n  Default: 30 seconds\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI AutoScaling.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-autoscaling-1)\n\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.AutoScaling.1 finding\n  HealthCheckGracePeriod:\n    type: Integer\n    default: 30\n    description: ELB Health Check Grace Period\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: AutoScalingGroupName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):autoscaling:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:autoScalingGroup:(?i:[0-9a-f]{11}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}):autoScalingGroupName/(.*)$'\n        expected_control_id:\n        - 'PCI.AutoScaling.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableAutoScalingGroupELBHealthCheck\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: 'SO0111-SHARR-Orchestrator-Member'\n      RuntimeParameters:\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAutoScalingGroupELBHealthCheck'\n        AutoScalingGroupName: '{{ParseInput.AutoScalingGroupName}}'\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'ASG health check type updated to ELB'\n        UpdatedBy: 'SHARR-PCI_3.2.1_AutoScaling.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.AutoScaling.1/Default"
   },
   "Condition": "EnablePCIAutoScaling1Condition"
  },
  "PCIPCIIAM7": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.IAM.7",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_IAM.7\n\n  ## What does this document do?\n  This document ensures that credentials unused for 90 days or greater are disabled.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of remediation runbook\n\n  SEE AWSConfigRemediation-RevokeUnusedIAMUserCredentials\n\n  ## Documentation Links\n  * [PCI IAM.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-iam-7)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.IAM.7 finding\n  HealthCheckGracePeriod:\n    type: Integer\n    default: 30\n    description: ELB Health Check Grace Period\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: IAMResourceId\n        Selector: $.Payload.details.AwsIamUser.UserId\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - 'PCI.IAM.7'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-RevokeUnusedIAMUserCredentials\n      RuntimeParameters:\n        IAMResourceId: '{{ ParseInput.IAMResourceId }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-RevokeUnusedIAMUserCredentials'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Deactivated unused keys and expired logins using the AWSConfigRemediation-RevokeUnusedIAMUserCredentials runbook.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_IAM.7'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.IAM.7/Default"
   },
   "Condition": "EnablePCIIAM7Condition"
  },
  "PCIPCICloudTrail2": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.CloudTrail.2",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_CloudTrail.2\n  ## What does this document do?\n  Creates a multi-region trail with KMS encryption and enables CloudTrail\n  Note: this remediation will create a NEW trail.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [PCI CloudTrail.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-2)\n\n\nschemaVersion: \"0.3\"\nassumeRole: \"{{ AutomationAssumeRole }}\"\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.CloudTrail.2 finding\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    description: The ARN of the KMS key created by SHARR for this remediation\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: AWSPartition\n        Selector: $.Payload.partition\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        region: '{{global:REGION}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - 'PCI.CloudTrail.2'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-CreateCloudTrailMultiRegionTrail\n      RuntimeParameters:\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateCloudTrailMultiRegionTrail'\n        AWSPartition: '{{global:AWS_PARTITION}}'\n\n  -\n    name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Multi-region, encrypted AWS CloudTrail successfully created'\n        UpdatedBy: 'SHARR-PCI_3.2.1_CloudTrail.2'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.CloudTrail.2/Default"
   },
   "Condition": "EnablePCICloudTrail2Condition"
  },
  "PCIPCICodeBuild2": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.CodeBuild.2",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_CodeBuild.2\n\n  ## What does this document do?\n  This document removes CodeBuild project environment variables containing clear text credentials and replaces them with Amazon EC2 Systems Manager Parameters.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI CodeBuild.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-codebuild-2)\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.CodeBuild.2 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: ProjectName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):codebuild:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:project/([A-Za-z0-9][A-Za-z0-9\\-_]{1,254})$'\n        expected_control_id: [ 'PCI.CodeBuild.2' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    inputs:\n      DocumentName: SHARR-ReplaceCodeBuildClearTextCredentials\n      RuntimeParameters:\n        ProjectName: '{{ ParseInput.ProjectName }}'\n        AutomationAssumeRole: 'arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/SO0111-ReplaceCodeBuildClearTextCredentials'\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ ParseInput.FindingId }}'\n        ProductArn: '{{ ParseInput.ProductArn }}'\n      Note:\n        Text: 'Replaced clear text credentials with SSM parameters.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_CodeBuild.2'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.CodeBuild.2/Default"
   },
   "Condition": "EnablePCICodeBuild2Condition"
  },
  "PCIPCICW1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.CW.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_CW.1\n  ## What does this document do?\n  Creates a log metric filter and alarm for usage of \"root\" account\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of remediation runbook.\n\n  ## Documentation Links\n  [PCI v3.2.1 PCI.CW.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cw-1-remediation)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.CW.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  LogGroupName:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/Metrics_LogGroupName}}\n    description: The name of the Log group to be used to create filters and metric alarms\n    allowedPattern: '.*'\n  MetricNamespace:\n    type: String\n    default: 'LogMetrics'\n    description: The name of the metric namespace where the metrics will be logged\n    allowedPattern: '.*'\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    description: The ARN of the KMS key created by SHARR for remediations\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: GroupId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: ControlId\n        Selector: $.Payload.control_id\n        Type: String\n    inputs:\n      InputPayload:\n        parse_id_pattern: ''\n        Finding: '{{Finding}}'\n        expected_control_id: [ 'PCI.CW.1' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: GetMetricFilterAndAlarmInputValue\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FilterName\n        Selector: $.Payload.filter_name\n        Type: String\n      - Name: FilterPattern\n        Selector: $.Payload.filter_pattern\n        Type: String\n      - Name: MetricName\n        Selector: $.Payload.metric_name\n        Type: String\n      - Name: MetricValue\n        Selector: $.Payload.metric_value\n        Type: Integer\n      - Name: AlarmName\n        Selector: $.Payload.alarm_name\n        Type: String\n      - Name: AlarmDesc\n        Selector: $.Payload.alarm_desc\n        Type: String\n      - Name: AlarmThreshold\n        Selector: $.Payload.alarm_threshold\n        Type: Integer\n    inputs:\n      InputPayload:\n        ControlId: '{{ParseInput.ControlId}}'\n      Runtime: python3.8\n      Handler: verify\n      Script: |-\n        ###############################################################################\n        #  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #\n        #                                                                             #\n        #  Licensed under the Apache License Version 2.0 (the \"License\"). You may not #\n        #  use this file except in compliance with the License. A copy of the License #\n        #  is located at                                                              #\n        #                                                                             #\n        #      http://www.apache.org/licenses/LICENSE-2.0/                            #\n        #                                                                             #\n        #  or in the \"license\" file accompanying this file. This file is distributed  #\n        #  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #\n        #  or implied. See the License for the specific language governing permis-    #\n        #  sions and limitations under the License.                                   #\n        ###############################################################################\n        \n        \n        PCI_mappings = {\n            \"PCI.CW.1\": {\n                \"filter_name\": \"SHARR_Filter_PCI_321_Finding_CW1_RootAccountUsage\",\n                \"filter_pattern\": '{$.userIdentity.type=\"Root\" && $.userIdentity.invokedBy NOT EXISTS && $.eventType !=\"AwsServiceEvent\"}',\n                \"metric_name\": \"SHARR_PCI_321_Finding_CW1_RootAccountUsage\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"SHARR_Alarm_PCI_321_Finding_CW1_RootAccountUsage\",\n                \"alarm_desc\": \"Alarm for PCI finding CW.1 RootAccountUsage\",\n                \"alarm_threshold\": 1\n            }\n        }\n        \n        \n        def verify(event, context):\n            \n            return PCI_mappings.get(event['ControlId'], None)\n        \n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-CreateLogMetricFilterAndAlarm\n      RuntimeParameters:\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateLogMetricFilterAndAlarm'\n        FilterName: '{{ GetMetricFilterAndAlarmInputValue.FilterName }}'\n        FilterPattern: '{{ GetMetricFilterAndAlarmInputValue.FilterPattern }}'\n        MetricName: '{{ GetMetricFilterAndAlarmInputValue.MetricName }}'\n        MetricValue: '{{ GetMetricFilterAndAlarmInputValue.MetricValue }}'\n        MetricNamespace: '{{ MetricNamespace }}'\n        AlarmName: '{{ GetMetricFilterAndAlarmInputValue.AlarmName }}'\n        AlarmDesc: '{{ GetMetricFilterAndAlarmInputValue.AlarmDesc }}'\n        AlarmThreshold: '{{ GetMetricFilterAndAlarmInputValue.AlarmThreshold }}'\n        LogGroupName: '{{ LogGroupName }}'\n        SNSTopicName: 'SO0111-SHARR-LocalAlarmNotification'\n        KMSKeyArn: '{{KMSKeyArn}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Added metric filter and alarm to the log group.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_CW.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.CW.1/Default"
   },
   "Condition": "EnablePCICW1Condition"
  },
  "PCIPCIEC21": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.EC2.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_EC2.1\n  ## What does this document do?\n  This document changes all public EC2 snapshots to private\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [PCI EC2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-1)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.EC2.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: AccountId\n        Selector: $.Payload.account_id\n        Type: String\n      - Name: TestMode\n        Selector: $.Payload.testmode\n        Type: Boolean\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        resource_index: 2\n        expected_control_id:\n        - 'PCI.EC2.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n    isEnd: false\n\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    inputs:\n      DocumentName: SHARR-MakeEBSSnapshotsPrivate\n      RuntimeParameters:\n        AccountId: '{{ParseInput.AccountId}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-MakeEBSSnapshotsPrivate'\n        TestMode: '{{ParseInput.TestMode}}'\n    isEnd: false\n\n  -\n    name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'EBS Snapshot modified to private'\n        UpdatedBy: 'SHARR-PCI_3.2.1_EC2.1'\n      Workflow:\n        Status: 'RESOLVED'\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.EC2.1/Default"
   },
   "Condition": "EnablePCIEC21Condition"
  },
  "PCIPCIEC22": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.EC2.2",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_EC2.2\n\n  ## What does this document do?\n  This document deletes ingress and egress rules from default security\n  group using the AWS SSM Runbook AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output from AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules SSM doc\n\n  ## Documentation Links\n  * [PCI EC2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-2)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.EC2.2 finding\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-RemoveVPCDefaultSecurityGroupRules\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: GroupId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:security-group/(sg-[0-9a-f]*)$'\n        expected_control_id:\n        - 'PCI.EC2.2'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-RemoveVPCDefaultSecurityGroupRules\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        GroupId: '{{ParseInput.GroupId}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n        - Id: '{{ParseInput.FindingId}}'\n          ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: Removed rules on default security group\n        UpdatedBy: SHARR-PCI_3.2.1_EC2.2\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.EC2.2/Default"
   },
   "Condition": "EnablePCIEC22Condition"
  },
  "PCIPCIEC25": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.EC2.5",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_EC2.5\n\n  ## What does this document do?\n  Removes public access to remove server administrative ports from an EC2 Security Group\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of AWS-DisablePublicAccessForSecurityGroup runbook.\n\n  ## Documentation Links\n  * [PCI v3.2.1 EC2.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-5)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.EC2.5 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: GroupId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-[0-9]):[0-9]{12}:security-group/(sg-[a-f0-9]{8,17})$'\n        expected_control_id: [ 'PCI.EC2.5' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: AWS-DisablePublicAccessForSecurityGroup\n      RuntimeParameters:\n        GroupId: '{{ ParseInput.GroupId }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-DisablePublicAccessForSecurityGroup'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Disabled public access to administrative ports in the security group {{ ParseInput.GroupId }}.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_EC2.5'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.EC2.5/Default"
   },
   "Condition": "EnablePCIEC25Condition"
  },
  "PCIPCIIAM8": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.IAM.8",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_PCI.IAM.8\n\n  ## What does this document do?\n  This document establishes a default password policy.\n\n  ## Security Standards and Controls\n  * CIS 1.5 - 1.11\n  * AFSBP IAM.7\n  * PCI IAM.8\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI IAM.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-iam-8)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.IAM.8 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id: [ 'PCI.IAM.8' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-SetIAMPasswordPolicy\n      RuntimeParameters:\n        AllowUsersToChangePassword: True\n        HardExpiry: True\n        MaxPasswordAge: 90\n        MinimumPasswordLength: 14\n        RequireSymbols: True\n        RequireNumbers: True\n        RequireUppercaseCharacters: True\n        RequireLowercaseCharacters: True\n        PasswordReusePrevention: 24\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetIAMPasswordPolicy'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Established a baseline password policy using the AWSConfigRemediation-SetIAMPasswordPolicy runbook.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_IAM.8'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.IAM.8/Default"
   },
   "Condition": "EnablePCIIAM8Condition"
  },
  "PCIPCIKMS1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.KMS.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_PCI.KMS.1\n\n  ## What does this document do?\n  Enables rotation for customer-managed KMS keys.\n\n  ## Security Standards and Controls\n  * CIS 2.8\n  * PCI KMS.1\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n  ## Documentation Links\n  * [PCI v3.2.1 PCI.KMS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-kms-1)\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.KMS.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableKeyRotation\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: KMSKeyId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:key/([A-Za-z0-9-]{36})$'\n        expected_control_id:\n        - 'PCI.KMS.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableKeyRotation\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        KeyId: '{{ParseInput.KMSKeyId}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled KMS Customer Managed Key rotation for {{ParseInput.KMSKeyId}}'\n        UpdatedBy: 'SHARR-PCI_3.2.1_PCI.KMS.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.KMS.1/Default"
   },
   "Condition": "EnablePCIKMS1Condition"
  },
  "PCIPCILambda1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.Lambda.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_Lambda.1\n\n  ## What does this document do?\n  This document removes the public resource policy. A public resource policy\n  contains a principal \"*\" or AWS: \"*\", which allows public access to the\n  function. The remediation is to remove the SID of the public policy.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [PCI Lambda.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-lambda-1)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.Lambda.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-RemoveLambdaPublicAccess\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: FunctionName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-us-gov|aws-cn):lambda:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:function:([a-zA-Z0-9\\-_]{1,64})$'\n        expected_control_id:\n        - 'PCI.Lambda.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-RemoveLambdaPublicAccess\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        FunctionName: '{{ ParseInput.FunctionName }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  -\n    name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Lamdba {{ParseInput.FunctionName}} policy updated to remove public access'\n        UpdatedBy: 'SHARR-PCI_3.2.1_Lambda.1 '\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.Lambda.1/Default"
   },
   "Condition": "EnablePCILambda1Condition"
  },
  "PCIPCIRDS1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.RDS.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_RDS.1\n  ## What does this document do?\n  This document changes public RDS snapshot to private\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [PCI RDS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-rds-1)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.RDS.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-MakeRDSSnapshotPrivate\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: DBSnapshotId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: DBSnapshotType\n        Selector: $.Payload.matches[0]\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: Type\n        Selector: $.Payload.type\n        Type: String\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(cluster-snapshot|snapshot):([a-zA-Z](?:[0-9a-zA-Z]+[-]{1})*[0-9a-zA-Z]{1,})$'\n        resource_index: 2\n        expected_control_id:\n        - 'PCI.RDS.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    nextStep: Remediation\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-MakeRDSSnapshotPrivate\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        DBSnapshotId: '{{ParseInput.DBSnapshotId}}'\n        DBSnapshotType: '{{ParseInput.DBSnapshotType}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n    nextStep: UpdateFinding\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n        - Id: '{{ParseInput.FindingId}}'\n          ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: RDS DB Snapshot modified to private\n        UpdatedBy: SHARR-PCI_3.2.1_RDS.1\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.RDS.1/Default"
   },
   "Condition": "EnablePCIRDS1Condition"
  },
  "PCIPCIRDS2": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.RDS.2",
    "Content": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\n---\ndescription: |\n  ### Document Name - SHARR-PCI_3.2.1_RDS.2\n  ## What does this document do?\n  This document disables public access to RDS instances by calling another SSM document\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [PCI RDS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-rds-2)\nschemaVersion: '0.3'\nassumeRole: '{{AutomationAssumeRole}}'\noutputs:\n- 'Remediation.Output'\n- 'ParseInput.AffectedObject'\nparameters:\n  Finding:\n    type: 'StringMap'\n    description: 'The input from the Orchestrator Step function for the PCI.RDS.2 finding'\n  AutomationAssumeRole:\n    type: 'String'\n    description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: 'String'\n    default: 'SO0111-DisablePublicAccessToRDSInstance'\n    allowedPattern: '^[\\w+=,.@/-]+'\nmainSteps:\n- name: 'ParseInput'\n  action: 'aws:executeScript'\n  inputs:\n    InputPayload:\n      Finding: '{{Finding}}'\n      parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:db:((?!.*--.*)(?!.*-$)[a-z][a-z0-9-]{0,62})$'\n      expected_control_id:\n      - 'PCI.RDS.2'\n    Runtime: 'python3.8'\n    Handler: 'parse_event'\n    Script: |-\n      #!/usr/bin/python\n      ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n      ## SPDX-License-Identifier: Apache-2.0\n      \n      import re\n      import json\n      import boto3\n      from botocore.config import Config\n      \n      def connect_to_config(boto_config):\n          return boto3.client('config', config=boto_config)\n      \n      def connect_to_ssm(boto_config):\n          return boto3.client('ssm', config=boto_config)\n      \n      def get_solution_id():\n          return 'SO0111'\n      \n      def get_solution_version():\n          ssm = connect_to_ssm(\n              Config(\n                  retries = {\n                      'mode': 'standard'\n                  },\n                  user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n              )\n          )\n          solution_version = 'unknown'\n          try:\n              ssm_parm_value = ssm.get_parameter(\n                  Name=f'/Solutions/{get_solution_id()}/member-version'\n              )['Parameter'].get('Value', 'unknown')\n              solution_version = ssm_parm_value\n          except Exception as e:\n              print(e)\n              print(f'ERROR getting solution version')\n          return solution_version\n      \n      def get_shortname(long_name):\n          short_name = {\n              'aws-foundational-security-best-practices': 'AFSBP',\n              'cis-aws-foundations-benchmark': 'CIS',\n              'pci-dss': 'PCI'\n          }\n          return short_name.get(long_name, None)\n      \n      def get_config_rule(rule_name):\n          boto_config = Config(\n              retries = {\n                  'mode': 'standard'\n              },\n              user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n          )\n          config_rule = None\n          try:\n              configsvc = connect_to_config(boto_config)\n              config_rule = configsvc.describe_config_rules(\n                  ConfigRuleNames=[ rule_name ]\n              ).get('ConfigRules', [])[0]\n          except Exception as e:\n              print(e)\n              exit(f'ERROR getting config rule {rule_name}')\n          return config_rule\n      \n      class FindingEvent:\n          \"\"\"\n          Finding object returns the parse fields from an input finding json object\n          \"\"\"\n          def _get_resource_id(self, parse_id_pattern, resource_index):\n              identifier_raw = self.finding_json['Resources'][0]['Id']\n              self.resource_id = identifier_raw\n              self.resource_id_matches = []\n      \n              if parse_id_pattern:\n                  identifier_match = re.match(\n                      parse_id_pattern,\n                      identifier_raw\n                  )\n      \n                  if identifier_match:\n                      for group in range(1, len(identifier_match.groups())+1):\n                          self.resource_id_matches.append(identifier_match.group(group))\n                      self.resource_id = identifier_match.group(resource_index)\n                  else:\n                      exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                  return\n      \n          def _get_standard_info(self):\n              match_finding_id = re.match(\n                  r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                  self.finding_json['Id']\n              )\n              if match_finding_id:\n                  self.standard_id = get_shortname(match_finding_id.group(1))\n                  self.standard_version = match_finding_id.group(2)\n                  self.control_id = match_finding_id.group(3)      \n              else:\n                  self.valid_finding = False\n                  self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n      \n          def _get_aws_config_rule(self):\n              # config_rule_id refers to the AWS Config Rule that produced the finding\n              if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                  self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                  self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n              return\n          \n          def _get_region_from_resource_id(self):\n              check_for_region = re.match(\n                  r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                  self.finding_json['Resources'][0]['Id']\n              )\n              if check_for_region:\n                  self.resource_region = check_for_region.group(1)\n      \n          def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n              self.valid_finding = True\n              self.resource_region = None\n              self.control_id = None\n              self.aws_config_rule_id = None\n              self.aws_config_rule = {}\n      \n              \"\"\"Populate fields\"\"\"\n              # v1.5\n              self.finding_json = finding_json\n              self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n              self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n      \n              # V1.4\n              self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n              if not re.match(r'^\\d{12}$', self.account_id):\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n              self.finding_id = self.finding_json.get('Id', None)              # deprecate\n              self.product_arn = self.finding_json.get('ProductArn', None)\n              if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n              self.details = self.finding_json['Resources'][0].get('Details', {})\n              # Test mode is used with fabricated finding data to tell the \n              # remediation runbook to run in test more (where supported)\n              # Currently not widely-used and perhaps should be deprecated.\n              self.testmode = bool('testmode' in self.finding_json)\n              self.resource = self.finding_json['Resources'][0]\n              self._get_region_from_resource_id()\n              self._get_aws_config_rule()\n              self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n      \n              # Validate control_id   \n              if not self.control_id:\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n              elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n      \n              if not self.resource_id:\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n      \n              if not self.valid_finding:\n                  # Error message and return error data\n                  msg = f'ERROR: {self.invalid_finding_reason}'\n                  exit(msg)\n      \n          def __str__(self):\n              return json.dumps(self.__dict__)\n      \n      '''\n      MAIN\n      '''\n      def parse_event(event, context):\n          finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n        \n          if not finding_event.valid_finding:\n              exit('ERROR: Finding is not valid')\n      \n          return {\n              \"account_id\": finding_event.account_id,\n              \"resource_id\": finding_event.resource_id, \n              \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n              \"control_id\": finding_event.control_id,\n              \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n              \"object\": finding_event.affected_object,\n              \"matches\": finding_event.resource_id_matches,\n              \"details\": finding_event.details,               # Deprecate v1.5.0+\n              \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n              \"resource\": finding_event.resource,\n              \"resource_region\": finding_event.resource_region,\n              \"finding\": finding_event.finding_json,\n              \"aws_config_rule\": finding_event.aws_config_rule\n          }\n  outputs:\n  - Name: 'DbiResourceId'\n    Selector: '$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId'\n    Type: 'String'\n  - Name: 'AffectedObject'\n    Selector: '$.Payload.object'\n    Type: 'StringMap'\n  - Name: 'FindingId'\n    Selector: '$.Payload.finding.Id'\n    Type: 'String'\n  - Name: 'ProductArn'\n    Selector: '$.Payload.finding.ProductArn'\n    Type: 'String'\n  - Name: 'RemediationRegion'\n    Selector: '$.Payload.resource_region'\n    Type: 'String'\n  - Name: 'RemediationAccount'\n    Selector: '$.Payload.account_id'\n    Type: 'String'\n- name: 'Remediation'\n  action: 'aws:executeAutomation'\n  inputs:\n    DocumentName: 'SHARR-DisablePublicAccessToRDSInstance'\n    TargetLocations:\n      - Accounts:\n        - '{{ParseInput.RemediationAccount}}'\n        Regions:\n        - '{{ParseInput.RemediationRegion}}'\n        ExecutionRoleName: '{{RemediationRoleName}}'\n    RuntimeParameters:\n      DbiResourceId: '{{ParseInput.DbiResourceId}}'\n      AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n- name: 'UpdateFinding'\n  action: 'aws:executeAwsApi'\n  inputs:\n    Service: 'securityhub'\n    Api: 'BatchUpdateFindings'\n    FindingIdentifiers:\n    - Id: '{{ParseInput.FindingId}}'\n      ProductArn: '{{ParseInput.ProductArn}}'\n    Note:\n      Text: 'Disabled public access to RDS instance'\n      UpdatedBy: 'SHARR-PCI_3.2.1_RDS.2'\n    Workflow:\n      Status: 'RESOLVED'\n  description: 'Update finding'\n  isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.RDS.2/Default"
   },
   "Condition": "EnablePCIRDS2Condition"
  },
  "PCIPCIRedshift1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.Redshift.1",
    "Content": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: Apache-2.0\n---\ndescription: |\n  ### Document Name - SHARR-PCI_3.2.1_Redshift.1\n  ## What does this document do?\n  This document disables public access to a Redshift cluster by calling another SSM document\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n  * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.\n\n  ## Documentation Links\n  * [PCI Redshift.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-redshift-1)\nschemaVersion: '0.3'\nassumeRole: '{{AutomationAssumeRole}}'\noutputs:\n- 'Remediation.Output'\n- 'ParseInput.AffectedObject'\nparameters:\n  Finding:\n    type: 'StringMap'\n    description: 'The input from the Orchestrator Step function for the PCI.Redshift.1 finding'\n  AutomationAssumeRole:\n    type: 'String'\n    description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: 'String'\n    default: 'SO0111-DisablePublicAccessToRedshiftCluster'\n    allowedPattern: '^[\\w+=,.@/-]+'\nmainSteps:\n- name: 'ParseInput'\n  action: 'aws:executeScript'\n  inputs:\n    InputPayload:\n      Finding: '{{Finding}}'\n      parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$'\n      expected_control_id:\n      - 'PCI.Redshift.1'\n    Runtime: 'python3.8'\n    Handler: 'parse_event'\n    Script: |-\n      #!/usr/bin/python\n      ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n      ## SPDX-License-Identifier: Apache-2.0\n      \n      import re\n      import json\n      import boto3\n      from botocore.config import Config\n      \n      def connect_to_config(boto_config):\n          return boto3.client('config', config=boto_config)\n      \n      def connect_to_ssm(boto_config):\n          return boto3.client('ssm', config=boto_config)\n      \n      def get_solution_id():\n          return 'SO0111'\n      \n      def get_solution_version():\n          ssm = connect_to_ssm(\n              Config(\n                  retries = {\n                      'mode': 'standard'\n                  },\n                  user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n              )\n          )\n          solution_version = 'unknown'\n          try:\n              ssm_parm_value = ssm.get_parameter(\n                  Name=f'/Solutions/{get_solution_id()}/member-version'\n              )['Parameter'].get('Value', 'unknown')\n              solution_version = ssm_parm_value\n          except Exception as e:\n              print(e)\n              print(f'ERROR getting solution version')\n          return solution_version\n      \n      def get_shortname(long_name):\n          short_name = {\n              'aws-foundational-security-best-practices': 'AFSBP',\n              'cis-aws-foundations-benchmark': 'CIS',\n              'pci-dss': 'PCI'\n          }\n          return short_name.get(long_name, None)\n      \n      def get_config_rule(rule_name):\n          boto_config = Config(\n              retries = {\n                  'mode': 'standard'\n              },\n              user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n          )\n          config_rule = None\n          try:\n              configsvc = connect_to_config(boto_config)\n              config_rule = configsvc.describe_config_rules(\n                  ConfigRuleNames=[ rule_name ]\n              ).get('ConfigRules', [])[0]\n          except Exception as e:\n              print(e)\n              exit(f'ERROR getting config rule {rule_name}')\n          return config_rule\n      \n      class FindingEvent:\n          \"\"\"\n          Finding object returns the parse fields from an input finding json object\n          \"\"\"\n          def _get_resource_id(self, parse_id_pattern, resource_index):\n              identifier_raw = self.finding_json['Resources'][0]['Id']\n              self.resource_id = identifier_raw\n              self.resource_id_matches = []\n      \n              if parse_id_pattern:\n                  identifier_match = re.match(\n                      parse_id_pattern,\n                      identifier_raw\n                  )\n      \n                  if identifier_match:\n                      for group in range(1, len(identifier_match.groups())+1):\n                          self.resource_id_matches.append(identifier_match.group(group))\n                      self.resource_id = identifier_match.group(resource_index)\n                  else:\n                      exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                  return\n      \n          def _get_standard_info(self):\n              match_finding_id = re.match(\n                  r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                  self.finding_json['Id']\n              )\n              if match_finding_id:\n                  self.standard_id = get_shortname(match_finding_id.group(1))\n                  self.standard_version = match_finding_id.group(2)\n                  self.control_id = match_finding_id.group(3)      \n              else:\n                  self.valid_finding = False\n                  self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n      \n          def _get_aws_config_rule(self):\n              # config_rule_id refers to the AWS Config Rule that produced the finding\n              if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                  self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                  self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n              return\n          \n          def _get_region_from_resource_id(self):\n              check_for_region = re.match(\n                  r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                  self.finding_json['Resources'][0]['Id']\n              )\n              if check_for_region:\n                  self.resource_region = check_for_region.group(1)\n      \n          def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n              self.valid_finding = True\n              self.resource_region = None\n              self.control_id = None\n              self.aws_config_rule_id = None\n              self.aws_config_rule = {}\n      \n              \"\"\"Populate fields\"\"\"\n              # v1.5\n              self.finding_json = finding_json\n              self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n              self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n      \n              # V1.4\n              self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n              if not re.match(r'^\\d{12}$', self.account_id):\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n              self.finding_id = self.finding_json.get('Id', None)              # deprecate\n              self.product_arn = self.finding_json.get('ProductArn', None)\n              if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n              self.details = self.finding_json['Resources'][0].get('Details', {})\n              # Test mode is used with fabricated finding data to tell the \n              # remediation runbook to run in test more (where supported)\n              # Currently not widely-used and perhaps should be deprecated.\n              self.testmode = bool('testmode' in self.finding_json)\n              self.resource = self.finding_json['Resources'][0]\n              self._get_region_from_resource_id()\n              self._get_aws_config_rule()\n              self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n      \n              # Validate control_id   \n              if not self.control_id:\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n              elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n      \n              if not self.resource_id:\n                  if self.valid_finding:\n                      self.valid_finding = False\n                      self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n      \n              if not self.valid_finding:\n                  # Error message and return error data\n                  msg = f'ERROR: {self.invalid_finding_reason}'\n                  exit(msg)\n      \n          def __str__(self):\n              return json.dumps(self.__dict__)\n      \n      '''\n      MAIN\n      '''\n      def parse_event(event, context):\n          finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n        \n          if not finding_event.valid_finding:\n              exit('ERROR: Finding is not valid')\n      \n          return {\n              \"account_id\": finding_event.account_id,\n              \"resource_id\": finding_event.resource_id, \n              \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n              \"control_id\": finding_event.control_id,\n              \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n              \"object\": finding_event.affected_object,\n              \"matches\": finding_event.resource_id_matches,\n              \"details\": finding_event.details,               # Deprecate v1.5.0+\n              \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n              \"resource\": finding_event.resource,\n              \"resource_region\": finding_event.resource_region,\n              \"finding\": finding_event.finding_json,\n              \"aws_config_rule\": finding_event.aws_config_rule\n          }\n  outputs:\n  - Name: 'ClusterIdentifier'\n    Selector: '$.Payload.resource_id'\n    Type: 'String'\n  - Name: 'AffectedObject'\n    Selector: '$.Payload.object'\n    Type: 'StringMap'\n  - Name: 'FindingId'\n    Selector: '$.Payload.finding.Id'\n    Type: 'String'\n  - Name: 'ProductArn'\n    Selector: '$.Payload.finding.ProductArn'\n    Type: 'String'\n  - Name: 'RemediationRegion'\n    Selector: '$.Payload.resource_region'\n    Type: 'String'\n  - Name: 'RemediationAccount'\n    Selector: '$.Payload.account_id'\n    Type: 'String'\n- name: 'Remediation'\n  action: 'aws:executeAutomation'\n  inputs:\n    DocumentName: 'SHARR-DisablePublicAccessToRedshiftCluster'\n    TargetLocations:\n      - Accounts:\n        - '{{ParseInput.RemediationAccount}}'\n        Regions:\n        - '{{ParseInput.RemediationRegion}}'\n        ExecutionRoleName: '{{RemediationRoleName}}'\n    RuntimeParameters:\n      ClusterIdentifier: '{{ParseInput.ClusterIdentifier}}'\n      AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n- name: 'UpdateFinding'\n  action: 'aws:executeAwsApi'\n  inputs:\n    Service: 'securityhub'\n    Api: 'BatchUpdateFindings'\n    FindingIdentifiers:\n    - Id: '{{ParseInput.FindingId}}'\n      ProductArn: '{{ParseInput.ProductArn}}'\n    Note:\n      Text: 'Disabled public access to Redshift cluster'\n      UpdatedBy: 'SHARR-PCI_3.2.1_Redshift.1'\n    Workflow:\n      Status: 'RESOLVED'\n  description: 'Update finding'\n  isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.Redshift.1/Default"
   },
   "Condition": "EnablePCIRedshift1Condition"
  },
  "PCIPCICloudTrail1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.CloudTrail.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_CloudTrail.1\n  ## What does this document do?\n  This document enables SSE KMS encryption for log files using the SHARR remediation KMS CMK\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n  ## Output Parameters\n  * Remediation.Output - Output from the remediation\n\n  ## Documentation Links\n  * [PCI CloudTrail.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-1)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.CloudTrail.1 finding\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: TrailArn\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: TrailRegion\n        Selector: $.Payload.resource_region\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - 'PCI.CloudTrail.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    inputs:\n      DocumentName: SHARR-EnableCloudTrailEncryption\n      RuntimeParameters:\n        TrailRegion: '{{ParseInput.TrailRegion}}'\n        TrailArn: '{{ParseInput.TrailArn}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableCloudTrailEncryption'\n        KMSKeyArn: '{{KMSKeyArn}}'\n    isEnd: false\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n        - Id: '{{ParseInput.FindingId}}'\n          ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: Encryption enabled on CloudTrail\n        UpdatedBy: SHARR-PCI_3.2.1_CloudTrail.1\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.CloudTrail.1/Default"
   },
   "Condition": "EnablePCICloudTrail1Condition"
  },
  "PCIPCIEC26": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.EC2.6",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_PCI.EC2.6\n\n  ## What does this document do?\n  Enables VPC Flow Logs for a VPC\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n  ## Documentation Links\n  * [PCI EC2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-6)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.EC2.6 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableVPCFlowLogs\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: VPC\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\\d{12}:vpc/(vpc-[0-9a-f]{8,17}$)'\n        expected_control_id:\n        - 'PCI.EC2.6'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableVPCFlowLogs\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        VPC: '{{ParseInput.VPC}}'\n        RemediationRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs-remediationRole'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled VPC Flow Logs for {{ParseInput.VPC}}'\n        UpdatedBy: 'SHARR-PCI_3.2.1_PCI.EC2.6'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.EC2.6/Default"
   },
   "Condition": "EnablePCIEC26Condition"
  },
  "PCIPCICloudTrail3": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.CloudTrail.3",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_CloudTrail.3\n\n  ## What does this document do?\n  This document enables CloudTrail log file validation.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI CloudTrail.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-3)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.CloudTrail.3 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableCloudTrailLogFileValidation\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: TrailName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/([A-Za-z0-9._-]{3,128})$'\n        expected_control_id:\n        - 'PCI.CloudTrail.3'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableCloudTrailLogFileValidation\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        TrailName: '{{ParseInput.TrailName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled CloudTrail log file validation.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_CloudTrail.3'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.CloudTrail.3/Default"
   },
   "Condition": "EnablePCICloudTrail3Condition"
  },
  "PCIPCICloudTrail4": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.CloudTrail.4",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_CloudTrail.4\n\n  ## What does this document do?\n  This document configures CloudTrail to log to CloudWatch Logs.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n   ## Documentation Links\n  * [PCI CloudTrail.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-4)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.CloudTrail.4 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableCloudTrailToCloudWatchLogging\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: TrailName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/([A-Za-z0-9._-]{3,128})$'\n        expected_control_id:\n        - 'PCI.CloudTrail.4'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableCloudTrailToCloudWatchLogging\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        TrailName: '{{ ParseInput.TrailName }}'\n        CloudWatchLogsRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CloudTrailToCloudWatchLogs'\n        LogGroupName: 'CloudTrail/{{ParseInput.TrailName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ParseInput.TrailName}}'\n        UpdatedBy: 'SHARR-PCI_3.2.1_CloudTrail.4'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.CloudTrail.4/Default"
   },
   "Condition": "EnablePCICloudTrail4Condition"
  },
  "PCIPCIConfig1": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.Config.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_Config.1\n  ## What does this document do?\n  Enables AWS Config:\n  * Turns on recording for all resources.\n  * Creates an encrypted bucket for Config logging.\n  * Creates a logging bucket for access logs for the config bucket\n  * Creates an SNS topic for Config notifications\n  * Creates a service-linked role\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [PCI Config.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-config-1)\n\nschemaVersion: \"0.3\"\nassumeRole: \"{{ AutomationAssumeRole }}\"\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.Config.1 finding\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    description: The ARN of the KMS key created by SHARR for remediations\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AWSPartition\n        Selector: $.Payload.partition\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - 'PCI.Config.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableAWSConfig\n      RuntimeParameters:\n        SNSTopicName: 'SO0111-SHARR-AWSConfigNotification'\n        KMSKeyArn: '{{KMSKeyArn}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAWSConfig'\n\n  -\n    name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'AWS Config enabled'\n        UpdatedBy: 'SHARR-PCI_3.2.1_Config.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.Config.1/Default"
   },
   "Condition": "EnablePCIConfig1Condition"
  },
  "PCIPCIS31": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.S3.1",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_S3.1\n\n  ## What does this document do?\n  This document blocks public access to an S3 bucket.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI v3.2.1 S3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-1)\n  * [PCI v3.2.1 S3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-2)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.S3.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: BucketName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'\n        expected_control_id: [ 'PCI.S3.1', 'PCI.S3.2' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-ConfigureS3BucketPublicAccessBlock\n      RuntimeParameters:\n        BucketName: '{{ParseInput.BucketName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketPublicAccessBlock'\n        RestrictPublicBuckets: true\n        BlockPublicAcls: true\n        IgnorePublicAcls: true\n        BlockPublicPolicy: true\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Disabled public access to S3 bucket.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_S3.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.S3.1/Default"
   },
   "Condition": "EnablePCIS31Condition"
  },
  "PCIPCIS34": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.S3.4",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_PCI.S3.4\n\n  ## What does this document do?\n  This document enables AES-256 as the default encryption for an S3 bucket.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI v3.2.1 S3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-4)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.S3.4 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n      type: String\n      default: \"SO0111-EnableDefaultEncryptionS3\"\n      allowedPattern: '^[\\w+=,.@-]+'\n  KmsKeyAlias:\n      type: String\n      description: (Required) KMS Customer-Managed Key (CMK) alias or the default value which is created in the SSM parameter at solution deployment (default-s3-encryption) is used to identify that the s3 bucket encryption value should be set to AES-256.\n      default: >-\n        {{ssm:/Solutions/SO0111/afsbp/1.0.0/S3.4/KmsKeyAlias}}\n      allowedPattern: '^$|^[a-zA-Z0-9/_-]{1,256}$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: AccountId\n        Selector: $.Payload.account_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: BucketName\n        Selector: $.Payload.resource_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'\n        expected_control_id: [ 'PCI.S3.4' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableDefaultEncryptionS3\n      RuntimeParameters:\n        AccountId: '{{ParseInput.AccountId}}'\n        BucketName: '{{ParseInput.BucketName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n        KmsKeyAlias: '{{KmsKeyAlias}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled default encryption for {{ParseInput.BucketName}}'\n        UpdatedBy: 'SHARR-PCI_3.2.1_PCI.S3.4'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.S3.4/Default"
   },
   "Condition": "EnablePCIS34Condition"
  },
  "PCIPCIS35": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.S3.5",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_PCI.S3.5\n\n  ## What does this document do?\n  This document adds a bucket policy to restrict internet access to https only.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI v3.2.1 S3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-5)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.S3.5 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: BucketName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: AccountId\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'\n        expected_control_id: [ 'PCI.S3.5' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-SetSSLBucketPolicy\n      RuntimeParameters:\n        BucketName: '{{ParseInput.BucketName}}'\n        AccountId: '{{ParseInput.AccountId}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetSSLBucketPolicy'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Added SSL-only access policy to S3 bucket.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_PCI.S3.5'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.S3.5/Default"
   },
   "Condition": "EnablePCIS35Condition"
  },
  "PCIPCIS36": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-PCI_3.2.1_PCI.S3.6",
    "Content": "description: |\n  ### Document Name - SHARR-PCI_3.2.1_S3.6\n\n  ## What does this document do?\n  This document blocks public access to all buckets by default at the account level.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [PCI v3.2.1 S3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-6)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the PCI.S3.6 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: AccountId\n        Selector: $.Payload.account_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id: [ 'PCI.S3.6' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-ConfigureS3PublicAccessBlock\n      RuntimeParameters:\n        AccountId: '{{ParseInput.AccountId}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3PublicAccessBlock'\n        RestrictPublicBuckets: true\n        BlockPublicAcls: true\n        IgnorePublicAcls: true\n        BlockPublicPolicy: true\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Configured the account to block public S3 access.'\n        UpdatedBy: 'SHARR-PCI_3.2.1_S3.6'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "PCI321MemberStack/PCI PCI.S3.6/Default"
   },
   "Condition": "EnablePCIS36Condition"
  }
 }
}