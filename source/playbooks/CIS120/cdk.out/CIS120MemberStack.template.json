{
 "Description": "(SO0111C) AWS Security Hub Automated Response & Remediation CIS 1.2.0 Compliance Pack - Member Account, v1.50.mybuild",
 "AWSTemplateFormatVersion": "2010-09-09",
 "Parameters": {
  "SecHubAdminAccount": {
   "Type": "String",
   "AllowedPattern": "\\d{12}",
   "Description": "Admin account number"
  },
  "Enable13": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 1.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable14": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 1.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable15": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 1.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable21": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable22": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable23": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable24": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable25": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable26": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable27": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable28": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable29": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 2.9 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable31": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable41": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 4.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  },
  "Enable43": {
   "Type": "String",
   "Default": "Available",
   "AllowedValues": [
    "Available",
    "NOT Available"
   ],
   "Description": "Enable/disable availability of remediation for CIS version 1.2.0 Control 4.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account."
  }
 },
 "Conditions": {
  "Enable13Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable13"
    },
    "Available"
   ]
  },
  "Enable14Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable14"
    },
    "Available"
   ]
  },
  "Enable15Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable15"
    },
    "Available"
   ]
  },
  "Enable21Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable21"
    },
    "Available"
   ]
  },
  "Enable22Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable22"
    },
    "Available"
   ]
  },
  "Enable23Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable23"
    },
    "Available"
   ]
  },
  "Enable24Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable24"
    },
    "Available"
   ]
  },
  "Enable25Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable25"
    },
    "Available"
   ]
  },
  "Enable26Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable26"
    },
    "Available"
   ]
  },
  "Enable27Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable27"
    },
    "Available"
   ]
  },
  "Enable28Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable28"
    },
    "Available"
   ]
  },
  "Enable29Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable29"
    },
    "Available"
   ]
  },
  "Enable31Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable31"
    },
    "Available"
   ]
  },
  "Enable41Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable41"
    },
    "Available"
   ]
  },
  "Enable43Condition": {
   "Fn::Equals": [
    {
     "Ref": "Enable43"
    },
    "Available"
   ]
  }
 },
 "Resources": {
  "CIS13": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_1.3",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_1.3\n\n  ## What does this document do?\n  This document ensures that credentials unused for 90 days or greater are disabled.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of DescribeAutoScalingGroups API.\n\n  ## Documentation Links\n  * [CIS v1.2.0 1.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.3)\n\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 1.3 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: IAMUser\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: IAMResourceId\n        Selector: $.Payload.details.AwsIamUser.UserId\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):iam::\\d{12}:user(?:(?:\\u002F)|(?:\\u002F[\\u0021-\\u007F]{1,510}\\u002F))([\\w+=,.@-]{1,64})$'\n        expected_control_id:\n        - '1.3'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-RevokeUnusedIAMUserCredentials\n      RuntimeParameters:\n        IAMResourceId: '{{ ParseInput.IAMResourceId }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-RevokeUnusedIAMUserCredentials'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Deactivated unused keys and expired logins for {{ ParseInput.IAMUser }}.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_1.3'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 1.3/Default"
   },
   "Condition": "Enable13Condition"
  },
  "CIS14": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_1.4",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_1.4\n\n  ## What does this document do?\n  This document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [CIS v1.2.0 1.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.4)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 1.4 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  MaxCredentialUsageAge:\n    type: String\n    description: (Required) Maximum number of days a key can be unrotated. The default value is 90 days.\n    allowedPattern: ^[1-9][0-9]{0,3}|10000$\n    default: \"90\"\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-RevokeUnrotatedKeys\"\n    allowedPattern: '^[\\w+=,.@-]+'\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: IAMUser\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: IAMResourceId\n        Selector: $.Payload.details.AwsIamUser.UserId\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):iam::\\d{12}:user(?:(?:\\u002F)|(?:\\u002F[\\u0021-\\u007F]{1,510}\\u002F))([\\w+=,.@-]{1,64})$'\n        expected_control_id:\n        - '1.4'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-RevokeUnrotatedKeys\n      RuntimeParameters:\n        IAMResourceId: '{{ ParseInput.IAMResourceId }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n        MaxCredentialUsageAge: '{{MaxCredentialUsageAge}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Deactivated unrotated keys for {{ ParseInput.IAMUser }}.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_1.4'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 1.4/Default"
   },
   "Condition": "Enable14Condition"
  },
  "CIS15": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_1.5",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_1.5\n\n  ## What does this document do?\n  This document establishes a default password policy.\n\n  ## Security Standards and Controls\n  * CIS 1.5 - 1.11\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [CIS v1.2.0 1.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.5)\n  * [CIS v1.2.0 1.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.6)\n  * [CIS v1.2.0 1.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.7)\n  * [CIS v1.2.0 1.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.8)\n  * [CIS v1.2.0 1.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.9)\n  * [CIS v1.2.0 1.10](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.10)\n  * [CIS v1.2.0 1.11](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.11)\n\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 1.5 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id: [ '1.5', '1.6', '1.7', '1.8', '1.9', '1.10', '1.11' ]\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-SetIAMPasswordPolicy\n      RuntimeParameters:\n        AllowUsersToChangePassword: True\n        HardExpiry: True\n        MaxPasswordAge: 90\n        MinimumPasswordLength: 14\n        RequireSymbols: True\n        RequireNumbers: True\n        RequireUppercaseCharacters: True\n        RequireLowercaseCharacters: True\n        PasswordReusePrevention: 24\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetIAMPasswordPolicy'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Established a baseline password policy using the AWSConfigRemediation-SetIAMPasswordPolicy runbook.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_1.5'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 1.5/Default"
   },
   "Condition": "Enable15Condition"
  },
  "CIS21": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.1",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.1\n\n  ## What does this document do?\n  Creates a multi-region trail with KMS encryption and enables CloudTrail\n  Note: this remediation will create a NEW trail.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.1)\n\nschemaVersion: \"0.3\"\nassumeRole: \"{{ AutomationAssumeRole }}\"\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.1 finding\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    description: The ARN of the KMS key created by SHARR for this remediation\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: ResourceId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: AWSPartition\n        Selector: $.Payload.partition\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - '2.1'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-CreateCloudTrailMultiRegionTrail\n      RuntimeParameters:\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateCloudTrailMultiRegionTrail'\n        AWSPartition: '{{global:AWS_PARTITION}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Multi-region, encrypted AWS CloudTrail successfully created'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.11'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.1/Default"
   },
   "Condition": "Enable21Condition"
  },
  "CIS22": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.2",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.2\n\n  ## What does this document do?\n  This document enables CloudTrail log file validation.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.2)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.2 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableCloudTrailLogFileValidation\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: TrailName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/([A-Za-z0-9._-]{3,128})$'\n        expected_control_id:\n        - '2.2'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableCloudTrailLogFileValidation\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        TrailName: '{{ParseInput.TrailName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled CloudTrail log file validation.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.2'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.2/Default"
   },
   "Condition": "Enable22Condition"
  },
  "CIS23": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.3",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.3\n\n  ## What does this document do?\n  This document blocks public access to the CloudTrail S3 bucket.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.3)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.3 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: BucketName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'\n        expected_control_id:\n        - '2.3'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-ConfigureS3BucketPublicAccessBlock\n      RuntimeParameters:\n        BucketName: '{{ParseInput.BucketName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketPublicAccessBlock'\n        RestrictPublicBuckets: true\n        BlockPublicAcls: true\n        IgnorePublicAcls: true\n        BlockPublicPolicy: true\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Disabled public access to CloudTrail logs bucket.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.3'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.3/Default"
   },
   "Condition": "Enable23Condition"
  },
  "CIS24": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.4",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.4\n\n  ## What does this document do?\n  This document configures CloudTrail to log to CloudWatch Logs.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.4)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.4 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableCloudTrailToCloudWatchLogging\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: TrailName\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:trail/([A-Za-z0-9._-]{3,128})$'\n        expected_control_id:\n        - '2.4'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableCloudTrailToCloudWatchLogging\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        TrailName: '{{ ParseInput.TrailName }}'\n        CloudWatchLogsRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CloudTrailToCloudWatchLogs'\n        LogGroupName: 'CloudTrail/{{ParseInput.TrailName}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ParseInput.TrailName}}'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.4'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.4/Default"
   },
   "Condition": "Enable24Condition"
  },
  "CIS25": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.5",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.5\n  ## What does this document do?\n  Enables AWS Config:\n  * Turns on recording for all resources.\n  * Creates an encrypted bucket for Config logging.\n  * Creates a logging bucket for access logs for the config bucket\n  * Creates an SNS topic for Config notifications\n  * Creates a service-linked role\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.5](https://docs.aws.amazon.com/console/securityhub/standards-cis-2.5/remediation)\n\nschemaVersion: \"0.3\"\nassumeRole: \"{{ AutomationAssumeRole }}\"\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.5 finding\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    description: The ARN of the KMS key created by SHARR for remediations\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - '2.5'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableAWSConfig\n      RuntimeParameters:\n        SNSTopicName: 'SO0111-SHARR-AWSConfigNotification'\n        KMSKeyArn: '{{KMSKeyArn}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAWSConfig'\n\n  -\n    name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'AWS Config enabled'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.5'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.5/Default"
   },
   "Condition": "Enable25Condition"
  },
  "CIS26": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.6",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.6\n\n  ## What does this document do?\n  Configures access logging for a CloudTrail S3 bucket.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.6)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.6 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: CloudTrailBucket\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([a-z0-9.-]{3,63})$'\n        expected_control_id:\n        - '2.6'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: CreateAccessLoggingBucket\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-CreateAccessLoggingBucket\n      RuntimeParameters:\n        BucketName: 'so0111-cloudtrailaccesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateAccessLoggingBucket'\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: AWS-ConfigureS3BucketLogging\n      RuntimeParameters:\n        BucketName: '{{ParseInput.CloudTrailBucket}}'\n        GrantedPermission: ['READ']\n        GranteeType: ['Group']\n        GranteeUri: ['http://acs.amazonaws.com/groups/s3/LogDelivery']\n        TargetPrefix: ['{{ParseInput.CloudTrailBucket}}/']\n        TargetBucket: ['so0111-cloudtrailaccesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}']\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketLogging'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Created S3 bucket so0111-cloudtrailaccesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}\n          for logging access to {{ParseInput.CloudTrailBucket}}'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.6'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.6/Default"
   },
   "Condition": "Enable26Condition"
  },
  "CIS27": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.7",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.7\n  ## What does this document do?\n  This document enables SSE KMS encryption for log files using the SHARR remediation KMS CMK\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n  ## Output Parameters\n  * Remediation.Output - Output from UpdateTrail API\n  ## Documentation Links\n  * [CIS v1.2.0 2.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.7)\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - Remediation.Output\n  - ParseInput.AffectedObject\nparameters:\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.7 finding\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\nmainSteps:\n  -\n    name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: TrailArn\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: TrailRegion\n        Selector: $.Payload.resource_region\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: ''\n        expected_control_id:\n        - '2.7'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n  -\n    name: Remediation\n    action: 'aws:executeAutomation'\n    inputs:\n      DocumentName: SHARR-EnableCloudTrailEncryption\n      RuntimeParameters:\n        TrailRegion: '{{ParseInput.TrailRegion}}'\n        TrailArn: '{{ParseInput.TrailArn}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableCloudTrailEncryption'\n        KMSKeyArn: '{{KMSKeyArn}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n        - Id: '{{ParseInput.FindingId}}'\n          ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Encryption enabled on CloudTrail {{ParseInput.TrailArn}}'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.7'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.7/Default"
   },
   "Condition": "Enable27Condition"
  },
  "CIS28": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.8",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.8\n\n  ## What does this document do?\n  Enables rotation for customer-managed KMS keys.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.8)\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.8 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-EnableKeyRotation\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: KMSKeyId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:key/([A-Za-z0-9-]{36})$'\n        expected_control_id:\n        - '2.8'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    inputs:\n      DocumentName: SHARR-EnableKeyRotation\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        KeyId: '{{ParseInput.KMSKeyId}}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled KMS Customer Managed Key rotation for {{ParseInput.KMSKeyId}}'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.8'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.8/Default"
   },
   "Condition": "Enable28Condition"
  },
  "CIS29": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_2.9",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_2.9\n\n  ## What does this document do?\n  Enables VPC Flow Logs for a VPC\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Remediation results\n\n  ## Documentation Links\n  * [CIS v1.2.0 2.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.9)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 2.9 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: VPC\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\\d{12}:vpc/(vpc-[0-9a-f]{8,17})$'\n        expected_control_id:\n        - '2.9'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-EnableVPCFlowLogs\n      RuntimeParameters:\n        VPC: '{{ParseInput.VPC}}'\n        RemediationRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs-remediationRole'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Enabled VPC Flow Logs for {{ParseInput.VPC}}'\n        UpdatedBy: 'SHARR-CIS_1.2.0_2.9'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 2.9/Default"
   },
   "Condition": "Enable29Condition"
  },
  "CIS31": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_3.1",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_3.x\n\n  ## What does this document do?\n  Remediates the following CIS findings:\n\n  3.1 - Creates a log metric filter and alarm for unauthorized API calls\n  3.2 - Creates a log metric filter and alarm for AWS Management Console sign-in without MFA\n  3.3 - Creates a log metric filter and alarm for usage of \"root\" account\n  3.4 - Creates a log metric filter and alarm for for IAM policy changes\n  3.5 - Creates a log metric filter and alarm for CloudTrail configuration changes\n  3.6 - Creates a log metric filter and alarm for AWS Management Console authentication failures\n  3.7 - Creates a log metric filter and alarm for disabling or scheduled deletion of customer created CMKs\n  3.8 - Creates a log metric filter and alarm for S3 bucket policy changes\n  3.9 - Creates a log metric filter and alarm for AWS Config configuration changes\n  3.10 - Creates a log metric filter and alarm for security group changes\n  3.11 - Creates a log metric filter and alarm for changes to Network Access Control Lists (NACL)\n  3.12 - Creates a log metric filter and alarm for changes to network gateways\n  3.13 - Creates a log metric filter and alarm for route table changes\n  3.14 - Creates a log metric filter and alarm for VPC changes\n\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of remediation runbook.\n\n  ## Documentation Links\n  [CIS v1.2.0 3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.1)\n  [CIS v1.2.0 3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.2)\n  [CIS v1.2.0 3.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.3)\n  [CIS v1.2.0 3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.4)\n  [CIS v1.2.0 3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.5)\n  [CIS v1.2.0 3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.6)\n  [CIS v1.2.0 3.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.7)\n  [CIS v1.2.0 3.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.8)\n  [CIS v1.2.0 3.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.9)\n  [CIS v1.2.0 3.10](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.10)\n  [CIS v1.2.0 3.11](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.11)\n  [CIS v1.2.0 3.12](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.12)\n  [CIS v1.2.0 3.13](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.13)\n  [CIS v1.2.0 3.14](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.14)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 3.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  LogGroupName:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/Metrics_LogGroupName}}\n    description: The name of the Log group to be used to create filters and metric alarms\n    allowedPattern: '.*'\n  MetricNamespace:\n    type: String\n    default: 'LogMetrics'\n    description: The name of the metric namespace where the metrics will be logged\n    allowedPattern: '.*'\n  KMSKeyArn:\n    type: String\n    default: >-\n      {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}\n    description: The ARN of the KMS key created by SHARR for remediations\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: GroupId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: ControlId\n        Selector: $.Payload.control_id\n        Type: String\n    inputs:\n      InputPayload:\n        parse_id_pattern: ''\n        Finding: '{{Finding}}'\n        expected_control_id: [ '3.1', '3.2', '3.3', '3.4', '3.5', '3.6', '3.7', '3.8', '3.9', '3.10', '3.11', '3.12', '3.13','3.14']\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: GetMetricFilterAndAlarmInputValue\n    action: 'aws:executeScript'\n    outputs:\n      - Name: FilterName\n        Selector: $.Payload.filter_name\n        Type: String\n      - Name: FilterPattern\n        Selector: $.Payload.filter_pattern\n        Type: String\n      - Name: MetricName\n        Selector: $.Payload.metric_name\n        Type: String\n      - Name: MetricValue\n        Selector: $.Payload.metric_value\n        Type: Integer\n      - Name: AlarmName\n        Selector: $.Payload.alarm_name\n        Type: String\n      - Name: AlarmDesc\n        Selector: $.Payload.alarm_desc\n        Type: String\n      - Name: AlarmThreshold\n        Selector: $.Payload.alarm_threshold\n        Type: Integer\n    inputs:\n      InputPayload:\n        ControlId: '{{ParseInput.ControlId}}'\n      Runtime: python3.8\n      Handler: verify\n      Script: |-\n        ###############################################################################\n        #  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #\n        #                                                                             #\n        #  Licensed under the Apache License Version 2.0 (the \"License\"). You may not #\n        #  use this file except in compliance with the License. A copy of the License #\n        #  is located at                                                              #\n        #                                                                             #\n        #      http://www.apache.org/licenses/LICENSE-2.0/                            #\n        #                                                                             #\n        #  or in the \"license\" file accompanying this file. This file is distributed  #\n        #  on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #\n        #  or implied. See the License for the specific language governing permis-    #\n        #  sions and limitations under the License.                                   #\n        ###############################################################################\n        \n        \n        CIS_mappings = {\n            \"3.1\": {\n                \"filter_name\": \"UnauthorizedAPICalls\",\n                \"filter_pattern\": '{($.errorCode=\"*UnauthorizedOperation\") || ($.errorCode=\"AccessDenied*\")}',\n                \"metric_name\": \"UnauthorizedAPICalls\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"UnauthorizedAPICalls\",\n                \"alarm_desc\": \"Alarm for UnauthorizedAPICalls > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.2\": {\n                \"filter_name\": \"ConsoleSigninWithoutMFA\",\n                \"filter_pattern\": '{($.eventName=\"ConsoleLogin\") && ($.additionalEventData.MFAUsed !=\"Yes\")}',\n                \"metric_name\": \"ConsoleSigninWithoutMFA\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"ConsoleSigninWithoutMFA\",\n                \"alarm_desc\": \"Alarm for ConsoleSigninWithoutMFA > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.3\": {\n                \"filter_name\": \"RootAccountUsage\",\n                \"filter_pattern\": '{$.userIdentity.type=\"Root\" && $.userIdentity.invokedBy NOT EXISTS && $.eventType !=\"AwsServiceEvent\"}',\n                \"metric_name\": \"RootAccountUsage\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"RootAccountUsage\",\n                \"alarm_desc\": \"Alarm for RootAccountUsage > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.4\": {\n                \"filter_name\": \"IAMPolicyChanges\",\n                \"filter_pattern\": '{($.eventName=DeleteGroupPolicy) || ($.eventName=DeleteRolePolicy) || ($.eventName=DeleteUserPolicy) || ($.eventName=PutGroupPolicy) || ($.eventName=PutRolePolicy) || ($.eventName=PutUserPolicy) || ($.eventName=CreatePolicy) || ($.eventName=DeletePolicy) || ($.eventName=CreatePolicyVersion) || ($.eventName=DeletePolicyVersion) || ($.eventName=AttachRolePolicy) || ($.eventName=DetachRolePolicy) || ($.eventName=AttachUserPolicy) || ($.eventName=DetachUserPolicy) || ($.eventName=AttachGroupPolicy) || ($.eventName=DetachGroupPolicy)}',\n                \"metric_name\": \"IAMPolicyChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"IAMPolicyChanges\",\n                \"alarm_desc\": \"Alarm for IAMPolicyChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.5\": {\n                \"filter_name\": \"CloudTrailChanges\",\n                \"filter_pattern\": '{($.eventName=CreateTrail) || ($.eventName=UpdateTrail) || ($.eventName=DeleteTrail) || ($.eventName=StartLogging) || ($.eventName=StopLogging)}',\n                \"metric_name\": \"CloudTrailChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"CloudTrailChanges\",\n                \"alarm_desc\": \"Alarm for CloudTrailChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.6\": {\n                \"filter_name\": \"ConsoleAuthenticationFailure\",\n                \"filter_pattern\": '{($.eventName=ConsoleLogin) && ($.errorMessage=\"Failed authentication\")}',\n                \"metric_name\": \"ConsoleAuthenticationFailure\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"ConsoleAuthenticationFailure\",\n                \"alarm_desc\": \"Alarm for ConsoleAuthenticationFailure > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.7\": {\n                \"filter_name\": \"DisableOrDeleteCMK\",\n                \"filter_pattern\": '{($.eventSource=kms.amazonaws.com) && (($.eventName=DisableKey) || ($.eventName=ScheduleKeyDeletion))}',\n                \"metric_name\": \"DisableOrDeleteCMK\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"DisableOrDeleteCMK\",\n                \"alarm_desc\": \"Alarm for DisableOrDeleteCMK > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.8\": {\n                \"filter_name\": \"S3BucketPolicyChanges\",\n                \"filter_pattern\": '{($.eventSource=s3.amazonaws.com) && (($.eventName=PutBucketAcl) || ($.eventName=PutBucketPolicy) || ($.eventName=PutBucketCors) || ($.eventName=PutBucketLifecycle) || ($.eventName=PutBucketReplication) || ($.eventName=DeleteBucketPolicy) || ($.eventName=DeleteBucketCors) || ($.eventName=DeleteBucketLifecycle) || ($.eventName=DeleteBucketReplication))}',\n                \"metric_name\": \"S3BucketPolicyChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"S3BucketPolicyChanges\",\n                \"alarm_desc\": \"Alarm for S3BucketPolicyChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.9\": {\n                \"filter_name\": \"AWSConfigChanges\",\n                \"filter_pattern\": '{($.eventSource=config.amazonaws.com) && (($.eventName=StopConfigurationRecorder) || ($.eventName=DeleteDeliveryChannel) || ($.eventName=PutDeliveryChannel) || ($.eventName=PutConfigurationRecorder))}',\n                \"metric_name\": \"AWSConfigChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"AWSConfigChanges\",\n                \"alarm_desc\": \"Alarm for AWSConfigChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.10\": {\n                \"filter_name\": \"SecurityGroupChanges\",\n                \"filter_pattern\": '{($.eventName=AuthorizeSecurityGroupIngress) || ($.eventName=AuthorizeSecurityGroupEgress) || ($.eventName=RevokeSecurityGroupIngress) || ($.eventName=RevokeSecurityGroupEgress) || ($.eventName=CreateSecurityGroup) || ($.eventName=DeleteSecurityGroup)}',\n                \"metric_name\": \"SecurityGroupChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"SecurityGroupChanges\",\n                \"alarm_desc\": \"Alarm for SecurityGroupChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.11\": {\n                \"filter_name\": \"NetworkACLChanges\",\n                \"filter_pattern\": '{($.eventName=CreateNetworkAcl) || ($.eventName=CreateNetworkAclEntry) || ($.eventName=DeleteNetworkAcl) || ($.eventName=DeleteNetworkAclEntry) || ($.eventName=ReplaceNetworkAclEntry) || ($.eventName=ReplaceNetworkAclAssociation)}',\n                \"metric_name\": \"NetworkACLChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"NetworkACLChanges\",\n                \"alarm_desc\": \"Alarm for NetworkACLChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.12\": {\n                \"filter_name\": \"NetworkGatewayChanges\",\n                \"filter_pattern\": '{($.eventName=CreateCustomerGateway) || ($.eventName=DeleteCustomerGateway) || ($.eventName=AttachInternetGateway) || ($.eventName=CreateInternetGateway) || ($.eventName=DeleteInternetGateway) || ($.eventName=DetachInternetGateway)}',\n                \"metric_name\": \"NetworkGatewayChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"NetworkGatewayChanges\",\n                \"alarm_desc\": \"Alarm for NetworkGatewayChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.13\": {\n                \"filter_name\": \"RouteTableChanges\",\n                \"filter_pattern\": '{($.eventName=CreateRoute) || ($.eventName=CreateRouteTable) || ($.eventName=ReplaceRoute) || ($.eventName=ReplaceRouteTableAssociation) || ($.eventName=DeleteRouteTable) || ($.eventName=DeleteRoute) || ($.eventName=DisassociateRouteTable)}',\n                \"metric_name\": \"RouteTableChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"RouteTableChanges\",\n                \"alarm_desc\": \"Alarm for RouteTableChanges > 0\",\n                \"alarm_threshold\": 1\n            },\n            \"3.14\": {\n                \"filter_name\": \"VPCChanges\",\n                \"filter_pattern\": '{($.eventName=CreateVpc) || ($.eventName=DeleteVpc) || ($.eventName=ModifyVpcAttribute) || ($.eventName=AcceptVpcPeeringConnection) || ($.eventName=CreateVpcPeeringConnection) || ($.eventName=DeleteVpcPeeringConnection) || ($.eventName=RejectVpcPeeringConnection) || ($.eventName=AttachClassicLinkVpc) || ($.eventName=DetachClassicLinkVpc) || ($.eventName=DisableVpcClassicLink) || ($.eventName=EnableVpcClassicLink)}',\n                \"metric_name\": \"VPCChanges\",\n                \"metric_value\": 1,\n                \"alarm_name\": \"VPCChanges\",\n                \"alarm_desc\": \"Alarm for VPCChanges > 0\",\n                \"alarm_threshold\": 1\n            }\n        }\n        \n        \n        def verify(event, context):\n            \n            return CIS_mappings.get(event['ControlId'], None)\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-CreateLogMetricFilterAndAlarm\n      RuntimeParameters:\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateLogMetricFilterAndAlarm'\n        FilterName: '{{ GetMetricFilterAndAlarmInputValue.FilterName }}'\n        FilterPattern: '{{ GetMetricFilterAndAlarmInputValue.FilterPattern }}'\n        MetricName: '{{ GetMetricFilterAndAlarmInputValue.MetricName }}'\n        MetricValue: '{{ GetMetricFilterAndAlarmInputValue.MetricValue }}'\n        MetricNamespace: '{{ MetricNamespace }}'\n        AlarmName: '{{ GetMetricFilterAndAlarmInputValue.AlarmName }}'\n        AlarmDesc: '{{ GetMetricFilterAndAlarmInputValue.AlarmDesc }}'\n        AlarmThreshold: '{{ GetMetricFilterAndAlarmInputValue.AlarmThreshold }}'\n        LogGroupName: '{{ LogGroupName }}'\n        SNSTopicName: 'SO0111-SHARR-LocalAlarmNotification'\n        KMSKeyArn: '{{KMSKeyArn}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Added metric filter to the log group and notifications to SNS topic SO0111-SHARR-LocalAlarmNotification.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_3.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 3.1/Default"
   },
   "Condition": "Enable31Condition"
  },
  "CIS41": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_4.1",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_4.1\n\n  ## What does this document do?\n  Removes public access from an EC2 Security Group for controls CIS 4.1 and CIS 4.2\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of AWS-DisablePublicAccessForSecurityGroup runbook.\n\n  ## Documentation Links\n  * [CIS v1.2.0 4.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.1)\n  * [CIS v1.2.0 4.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.2)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 4.1 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-DisablePublicAccessForSecurityGroup\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: GroupId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-[0-9]):[0-9]{12}:security-group/(sg-[a-f0-9]{8,17})$'\n        expected_control_id: ['4.1', '4.2']\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    inputs:\n      DocumentName: AWS-DisablePublicAccessForSecurityGroup\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        GroupId: '{{ ParseInput.GroupId }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Disabled public access to the security group {{ ParseInput.GroupId }}.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_4.1'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 4.1/Default"
   },
   "Condition": "Enable41Condition"
  },
  "CIS43": {
   "Type": "Custom::UpdatableRunbook",
   "Properties": {
    "ServiceToken": {
     "Fn::Join": [
      "",
      [
       "arn:",
       {
        "Ref": "AWS::Partition"
       },
       ":lambda:",
       {
        "Ref": "AWS::Region"
       },
       ":",
       {
        "Ref": "AWS::AccountId"
       },
       ":function:SO0111-SHARR-updatableRunbookProvider"
      ]
     ]
    },
    "Name": "SHARR-CIS_1.2.0_4.3",
    "Content": "description: |\n  ### Document Name - SHARR-CIS_1.2.0_4.3\n\n  ## What does this document do?\n  Removes all access from an EC2 Default Security Group to restrict all traffic.\n\n  ## Input Parameters\n  * Finding: (Required) Security Hub finding details JSON\n  * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n\n  ## Output Parameters\n  * Remediation.Output - Output of remediation runbook.\n\n  ## Documentation Links\n  [CIS v1.2.0 4.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.3)\n\nschemaVersion: '0.3'\nassumeRole: '{{ AutomationAssumeRole }}'\noutputs:\n  - ParseInput.AffectedObject\n  - Remediation.Output\nparameters:\n  Finding:\n    type: StringMap\n    description: The input from the Orchestrator Step function for the 4.3 finding\n  AutomationAssumeRole:\n    type: String\n    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.\n    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\\d{12}:role/[\\w+=,.@-]+$'\n  RemediationRoleName:\n    type: String\n    default: \"SO0111-RemoveVPCDefaultSecurityGroupRules\"\n    allowedPattern: '^[\\w+=,.@-]+'\n\nmainSteps:\n  - name: ParseInput\n    action: 'aws:executeScript'\n    outputs:\n      - Name: GroupId\n        Selector: $.Payload.resource_id\n        Type: String\n      - Name: FindingId\n        Selector: $.Payload.finding_id\n        Type: String\n      - Name: ProductArn\n        Selector: $.Payload.product_arn\n        Type: String\n      - Name: AffectedObject\n        Selector: $.Payload.object\n        Type: StringMap\n      - Name: RemediationRegion\n        Selector: $.Payload.resource_region\n        Type: String\n      - Name: RemediationAccount\n        Selector: $.Payload.account_id\n        Type: String\n    inputs:\n      InputPayload:\n        Finding: '{{Finding}}'\n        parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:security-group/(sg-[a-f0-9]{8,17})$'\n        expected_control_id:\n        - '4.3'\n      Runtime: python3.8\n      Handler: parse_event\n      Script: |-\n        #!/usr/bin/python\n        ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n        ## SPDX-License-Identifier: Apache-2.0\n        \n        import re\n        import json\n        import boto3\n        from botocore.config import Config\n        \n        def connect_to_config(boto_config):\n            return boto3.client('config', config=boto_config)\n        \n        def connect_to_ssm(boto_config):\n            return boto3.client('ssm', config=boto_config)\n        \n        def get_solution_id():\n            return 'SO0111'\n        \n        def get_solution_version():\n            ssm = connect_to_ssm(\n                Config(\n                    retries = {\n                        'mode': 'standard'\n                    },\n                    user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'\n                )\n            )\n            solution_version = 'unknown'\n            try:\n                ssm_parm_value = ssm.get_parameter(\n                    Name=f'/Solutions/{get_solution_id()}/member-version'\n                )['Parameter'].get('Value', 'unknown')\n                solution_version = ssm_parm_value\n            except Exception as e:\n                print(e)\n                print(f'ERROR getting solution version')\n            return solution_version\n        \n        def get_shortname(long_name):\n            short_name = {\n                'aws-foundational-security-best-practices': 'AFSBP',\n                'cis-aws-foundations-benchmark': 'CIS',\n                'pci-dss': 'PCI'\n            }\n            return short_name.get(long_name, None)\n        \n        def get_config_rule(rule_name):\n            boto_config = Config(\n                retries = {\n                    'mode': 'standard'\n                },\n                user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'\n            )\n            config_rule = None\n            try:\n                configsvc = connect_to_config(boto_config)\n                config_rule = configsvc.describe_config_rules(\n                    ConfigRuleNames=[ rule_name ]\n                ).get('ConfigRules', [])[0]\n            except Exception as e:\n                print(e)\n                exit(f'ERROR getting config rule {rule_name}')\n            return config_rule\n        \n        class FindingEvent:\n            \"\"\"\n            Finding object returns the parse fields from an input finding json object\n            \"\"\"\n            def _get_resource_id(self, parse_id_pattern, resource_index):\n                identifier_raw = self.finding_json['Resources'][0]['Id']\n                self.resource_id = identifier_raw\n                self.resource_id_matches = []\n        \n                if parse_id_pattern:\n                    identifier_match = re.match(\n                        parse_id_pattern,\n                        identifier_raw\n                    )\n        \n                    if identifier_match:\n                        for group in range(1, len(identifier_match.groups())+1):\n                            self.resource_id_matches.append(identifier_match.group(group))\n                        self.resource_id = identifier_match.group(resource_index)\n                    else:\n                        exit(f'ERROR: Invalid resource Id {identifier_raw}')   \n                    return\n        \n            def _get_standard_info(self):\n                match_finding_id = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d):\\d{12}:subscription/(.*?)/v/(\\d+\\.\\d+\\.\\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',\n                    self.finding_json['Id']\n                )\n                if match_finding_id:\n                    self.standard_id = get_shortname(match_finding_id.group(1))\n                    self.standard_version = match_finding_id.group(2)\n                    self.control_id = match_finding_id.group(3)      \n                else:\n                    self.valid_finding = False\n                    self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]}'\n        \n            def _get_aws_config_rule(self):\n                # config_rule_id refers to the AWS Config Rule that produced the finding\n                if \"RelatedAWSResources:0/type\" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':\n                    self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']\n                    self.aws_config_rule = get_config_rule(self.aws_config_rule_id)\n                return\n            \n            def _get_region_from_resource_id(self):\n                check_for_region = re.match(\n                    r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)):.*:.*$',\n                    self.finding_json['Resources'][0]['Id']\n                )\n                if check_for_region:\n                    self.resource_region = check_for_region.group(1)\n        \n            def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):\n                self.valid_finding = True\n                self.resource_region = None\n                self.control_id = None\n                self.aws_config_rule_id = None\n                self.aws_config_rule = {}\n        \n                \"\"\"Populate fields\"\"\"\n                # v1.5\n                self.finding_json = finding_json\n                self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches\n                self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id\n        \n                # V1.4\n                self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId\n                if not re.match(r'^\\d{12}$', self.account_id):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'\n                self.finding_id = self.finding_json.get('Id', None)              # deprecate\n                self.product_arn = self.finding_json.get('ProductArn', None)\n                if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\\d)::product/aws/securityhub$', self.product_arn):\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'\n                self.details = self.finding_json['Resources'][0].get('Details', {})\n                # Test mode is used with fabricated finding data to tell the \n                # remediation runbook to run in test more (where supported)\n                # Currently not widely-used and perhaps should be deprecated.\n                self.testmode = bool('testmode' in self.finding_json)\n                self.resource = self.finding_json['Resources'][0]\n                self._get_region_from_resource_id()\n                self._get_aws_config_rule()\n                self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}\n        \n                # Validate control_id   \n                if not self.control_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json[\"Id\"]} - missing Control Id'\n                elif self.control_id not in expected_control_id:  # ControlId is the expected value\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'\n        \n                if not self.resource_id:\n                    if self.valid_finding:\n                        self.valid_finding = False\n                        self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'\n        \n                if not self.valid_finding:\n                    # Error message and return error data\n                    msg = f'ERROR: {self.invalid_finding_reason}'\n                    exit(msg)\n        \n            def __str__(self):\n                return json.dumps(self.__dict__)\n        \n        '''\n        MAIN\n        '''\n        def parse_event(event, context):\n            finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))\n          \n            if not finding_event.valid_finding:\n                exit('ERROR: Finding is not valid')\n        \n            return {\n                \"account_id\": finding_event.account_id,\n                \"resource_id\": finding_event.resource_id, \n                \"finding_id\": finding_event.finding_id,         # Deprecate v1.5.0+\n                \"control_id\": finding_event.control_id,\n                \"product_arn\": finding_event.product_arn,       # Deprecate v1.5.0+\n                \"object\": finding_event.affected_object,\n                \"matches\": finding_event.resource_id_matches,\n                \"details\": finding_event.details,               # Deprecate v1.5.0+\n                \"testmode\": finding_event.testmode,             # Deprecate v1.5.0+\n                \"resource\": finding_event.resource,\n                \"resource_region\": finding_event.resource_region,\n                \"finding\": finding_event.finding_json,\n                \"aws_config_rule\": finding_event.aws_config_rule\n            }\n    isEnd: false\n\n  - name: Remediation\n    action: 'aws:executeAutomation'\n    isEnd: false\n    inputs:\n      DocumentName: SHARR-RemoveVPCDefaultSecurityGroupRules\n      TargetLocations:\n        - Accounts: [ '{{ParseInput.RemediationAccount}}' ]\n          Regions: [ '{{ParseInput.RemediationRegion}}' ]\n          ExecutionRoleName: '{{RemediationRoleName}}'\n      RuntimeParameters:\n        GroupId: '{{ ParseInput.GroupId }}'\n        AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'\n\n  - name: UpdateFinding\n    action: 'aws:executeAwsApi'\n    inputs:\n      Service: securityhub\n      Api: BatchUpdateFindings\n      FindingIdentifiers:\n      - Id: '{{ParseInput.FindingId}}'\n        ProductArn: '{{ParseInput.ProductArn}}'\n      Note:\n        Text: 'Removed all access to the default security group {{ ParseInput.GroupId }}.'\n        UpdatedBy: 'SHARR-CIS_1.2.0_4.3'\n      Workflow:\n        Status: RESOLVED\n    description: Update finding\n    isEnd: true\n\n",
    "DocumentFormat": "YAML",
    "VersionName": "v1.50.mybuild",
    "DocumentType": "Automation"
   },
   "UpdateReplacePolicy": "Delete",
   "DeletionPolicy": "Delete",
   "Metadata": {
    "aws:cdk:path": "CIS120MemberStack/CIS 4.3/Default"
   },
   "Condition": "Enable43Condition"
  }
 }
}