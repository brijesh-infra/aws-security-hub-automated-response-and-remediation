Description: (SO0111C) AWS Security Hub Automated Response & Remediation PCI 3.2.1 Compliance Pack - Member Account, v1.50.mybuild
AWSTemplateFormatVersion: "2010-09-09"
Parameters:
  SecHubAdminAccount:
    Type: String
    AllowedPattern: \d{12}
    Description: Admin account number
  EnablePCIAutoScaling1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.AutoScaling.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIIAM7:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.IAM.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCICloudTrail2:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCICodeBuild2:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CodeBuild.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCICW1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CW.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIEC21:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIEC22:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIEC25:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIIAM8:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.IAM.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIKMS1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.KMS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCILambda1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.Lambda.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIRDS1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.RDS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIRDS2:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.RDS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIRedshift1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.Redshift.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCICloudTrail1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIEC26:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.EC2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCICloudTrail3:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCICloudTrail4:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.CloudTrail.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIConfig1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.Config.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIS31:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIS34:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIS35:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnablePCIS36:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for PCI version 3.2.1 Control PCI.S3.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
Conditions:
  EnablePCIAutoScaling1Condition:
    Fn::Equals:
      - Ref: EnablePCIAutoScaling1
      - Available
  EnablePCIIAM7Condition:
    Fn::Equals:
      - Ref: EnablePCIIAM7
      - Available
  EnablePCICloudTrail2Condition:
    Fn::Equals:
      - Ref: EnablePCICloudTrail2
      - Available
  EnablePCICodeBuild2Condition:
    Fn::Equals:
      - Ref: EnablePCICodeBuild2
      - Available
  EnablePCICW1Condition:
    Fn::Equals:
      - Ref: EnablePCICW1
      - Available
  EnablePCIEC21Condition:
    Fn::Equals:
      - Ref: EnablePCIEC21
      - Available
  EnablePCIEC22Condition:
    Fn::Equals:
      - Ref: EnablePCIEC22
      - Available
  EnablePCIEC25Condition:
    Fn::Equals:
      - Ref: EnablePCIEC25
      - Available
  EnablePCIIAM8Condition:
    Fn::Equals:
      - Ref: EnablePCIIAM8
      - Available
  EnablePCIKMS1Condition:
    Fn::Equals:
      - Ref: EnablePCIKMS1
      - Available
  EnablePCILambda1Condition:
    Fn::Equals:
      - Ref: EnablePCILambda1
      - Available
  EnablePCIRDS1Condition:
    Fn::Equals:
      - Ref: EnablePCIRDS1
      - Available
  EnablePCIRDS2Condition:
    Fn::Equals:
      - Ref: EnablePCIRDS2
      - Available
  EnablePCIRedshift1Condition:
    Fn::Equals:
      - Ref: EnablePCIRedshift1
      - Available
  EnablePCICloudTrail1Condition:
    Fn::Equals:
      - Ref: EnablePCICloudTrail1
      - Available
  EnablePCIEC26Condition:
    Fn::Equals:
      - Ref: EnablePCIEC26
      - Available
  EnablePCICloudTrail3Condition:
    Fn::Equals:
      - Ref: EnablePCICloudTrail3
      - Available
  EnablePCICloudTrail4Condition:
    Fn::Equals:
      - Ref: EnablePCICloudTrail4
      - Available
  EnablePCIConfig1Condition:
    Fn::Equals:
      - Ref: EnablePCIConfig1
      - Available
  EnablePCIS31Condition:
    Fn::Equals:
      - Ref: EnablePCIS31
      - Available
  EnablePCIS34Condition:
    Fn::Equals:
      - Ref: EnablePCIS34
      - Available
  EnablePCIS35Condition:
    Fn::Equals:
      - Ref: EnablePCIS35
      - Available
  EnablePCIS36Condition:
    Fn::Equals:
      - Ref: EnablePCIS36
      - Available
Resources:
  PCIPCIAutoScaling1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.AutoScaling.1
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_PCI.AutoScaling.1

          ## What does this document do?
          This document enables ELB healthcheck on a given AutoScaling Group using the [UpdateAutoScalingGroup] API.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * HealthCheckGracePeriod: (Optional) Health check grace period when ELB health check is Enabled
          Default: 30 seconds
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI AutoScaling.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-autoscaling-1)


        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.AutoScaling.1 finding
          HealthCheckGracePeriod:
            type: Integer
            default: 30
            description: ELB Health Check Grace Period
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: AutoScalingGroupName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):autoscaling:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:autoScalingGroup:(?i:[0-9a-f]{11}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}):autoScalingGroupName/(.*)$'
                expected_control_id:
                - 'PCI.AutoScaling.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableAutoScalingGroupELBHealthCheck
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: 'SO0111-SHARR-Orchestrator-Member'
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAutoScalingGroupELBHealthCheck'
                AutoScalingGroupName: '{{ParseInput.AutoScalingGroupName}}'
          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'ASG health check type updated to ELB'
                UpdatedBy: 'SHARR-PCI_3.2.1_AutoScaling.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.AutoScaling.1/Default
    Condition: EnablePCIAutoScaling1Condition
  PCIPCIIAM7:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.IAM.7
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_IAM.7

          ## What does this document do?
          This document ensures that credentials unused for 90 days or greater are disabled.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of remediation runbook

          SEE AWSConfigRemediation-RevokeUnusedIAMUserCredentials

          ## Documentation Links
          * [PCI IAM.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-iam-7)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.IAM.7 finding
          HealthCheckGracePeriod:
            type: Integer
            default: 30
            description: ELB Health Check Grace Period
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: IAMResourceId
                Selector: $.Payload.details.AwsIamUser.UserId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'PCI.IAM.7'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RevokeUnusedIAMUserCredentials
              RuntimeParameters:
                IAMResourceId: '{{ ParseInput.IAMResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-RevokeUnusedIAMUserCredentials'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Deactivated unused keys and expired logins using the AWSConfigRemediation-RevokeUnusedIAMUserCredentials runbook.'
                UpdatedBy: 'SHARR-PCI_3.2.1_IAM.7'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.IAM.7/Default
    Condition: EnablePCIIAM7Condition
  PCIPCICloudTrail2:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.CloudTrail.2
      Content: |
        description: |
          ### Document Name - SHARR-PCI_3.2.1_CloudTrail.2
          ## What does this document do?
          Creates a multi-region trail with KMS encryption and enables CloudTrail
          Note: this remediation will create a NEW trail.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [PCI CloudTrail.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-2)


        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.CloudTrail.2 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for this remediation
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: AWSPartition
                Selector: $.Payload.partition
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                region: '{{global:REGION}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'PCI.CloudTrail.2'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-CreateCloudTrailMultiRegionTrail
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateCloudTrailMultiRegionTrail'
                AWSPartition: '{{global:AWS_PARTITION}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Multi-region, encrypted AWS CloudTrail successfully created'
                UpdatedBy: 'SHARR-PCI_3.2.1_CloudTrail.2'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.CloudTrail.2/Default
    Condition: EnablePCICloudTrail2Condition
  PCIPCICodeBuild2:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.CodeBuild.2
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_CodeBuild.2

          ## What does this document do?
          This document removes CodeBuild project environment variables containing clear text credentials and replaces them with Amazon EC2 Systems Manager Parameters.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI CodeBuild.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-codebuild-2)
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.CodeBuild.2 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: ProjectName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):codebuild:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:project/([A-Za-z0-9][A-Za-z0-9\-_]{1,254})$'
                expected_control_id: [ 'PCI.CodeBuild.2' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-ReplaceCodeBuildClearTextCredentials
              RuntimeParameters:
                ProjectName: '{{ ParseInput.ProjectName }}'
                AutomationAssumeRole: 'arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/SO0111-ReplaceCodeBuildClearTextCredentials'
          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ ParseInput.FindingId }}'
                ProductArn: '{{ ParseInput.ProductArn }}'
              Note:
                Text: 'Replaced clear text credentials with SSM parameters.'
                UpdatedBy: 'SHARR-PCI_3.2.1_CodeBuild.2'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.CodeBuild.2/Default
    Condition: EnablePCICodeBuild2Condition
  PCIPCICW1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.CW.1
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_CW.1
          ## What does this document do?
          Creates a log metric filter and alarm for usage of "root" account

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of remediation runbook.

          ## Documentation Links
          [PCI v3.2.1 PCI.CW.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cw-1-remediation)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.CW.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          LogGroupName:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/Metrics_LogGroupName}}
            description: The name of the Log group to be used to create filters and metric alarms
            allowedPattern: '.*'
          MetricNamespace:
            type: String
            default: 'LogMetrics'
            description: The name of the metric namespace where the metrics will be logged
            allowedPattern: '.*'
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for remediations
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: ControlId
                Selector: $.Payload.control_id
                Type: String
            inputs:
              InputPayload:
                parse_id_pattern: ''
                Finding: '{{Finding}}'
                expected_control_id: [ 'PCI.CW.1' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: GetMetricFilterAndAlarmInputValue
            action: 'aws:executeScript'
            outputs:
              - Name: FilterName
                Selector: $.Payload.filter_name
                Type: String
              - Name: FilterPattern
                Selector: $.Payload.filter_pattern
                Type: String
              - Name: MetricName
                Selector: $.Payload.metric_name
                Type: String
              - Name: MetricValue
                Selector: $.Payload.metric_value
                Type: Integer
              - Name: AlarmName
                Selector: $.Payload.alarm_name
                Type: String
              - Name: AlarmDesc
                Selector: $.Payload.alarm_desc
                Type: String
              - Name: AlarmThreshold
                Selector: $.Payload.alarm_threshold
                Type: Integer
            inputs:
              InputPayload:
                ControlId: '{{ParseInput.ControlId}}'
              Runtime: python3.8
              Handler: verify
              Script: |-
                ###############################################################################
                #  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
                #                                                                             #
                #  Licensed under the Apache License Version 2.0 (the "License"). You may not #
                #  use this file except in compliance with the License. A copy of the License #
                #  is located at                                                              #
                #                                                                             #
                #      http://www.apache.org/licenses/LICENSE-2.0/                            #
                #                                                                             #
                #  or in the "license" file accompanying this file. This file is distributed  #
                #  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
                #  or implied. See the License for the specific language governing permis-    #
                #  sions and limitations under the License.                                   #
                ###############################################################################
                
                
                PCI_mappings = {
                    "PCI.CW.1": {
                        "filter_name": "SHARR_Filter_PCI_321_Finding_CW1_RootAccountUsage",
                        "filter_pattern": '{$.userIdentity.type="Root" && $.userIdentity.invokedBy NOT EXISTS && $.eventType !="AwsServiceEvent"}',
                        "metric_name": "SHARR_PCI_321_Finding_CW1_RootAccountUsage",
                        "metric_value": 1,
                        "alarm_name": "SHARR_Alarm_PCI_321_Finding_CW1_RootAccountUsage",
                        "alarm_desc": "Alarm for PCI finding CW.1 RootAccountUsage",
                        "alarm_threshold": 1
                    }
                }
                
                
                def verify(event, context):
                    
                    return PCI_mappings.get(event['ControlId'], None)
                

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-CreateLogMetricFilterAndAlarm
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateLogMetricFilterAndAlarm'
                FilterName: '{{ GetMetricFilterAndAlarmInputValue.FilterName }}'
                FilterPattern: '{{ GetMetricFilterAndAlarmInputValue.FilterPattern }}'
                MetricName: '{{ GetMetricFilterAndAlarmInputValue.MetricName }}'
                MetricValue: '{{ GetMetricFilterAndAlarmInputValue.MetricValue }}'
                MetricNamespace: '{{ MetricNamespace }}'
                AlarmName: '{{ GetMetricFilterAndAlarmInputValue.AlarmName }}'
                AlarmDesc: '{{ GetMetricFilterAndAlarmInputValue.AlarmDesc }}'
                AlarmThreshold: '{{ GetMetricFilterAndAlarmInputValue.AlarmThreshold }}'
                LogGroupName: '{{ LogGroupName }}'
                SNSTopicName: 'SO0111-SHARR-LocalAlarmNotification'
                KMSKeyArn: '{{KMSKeyArn}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Added metric filter and alarm to the log group.'
                UpdatedBy: 'SHARR-PCI_3.2.1_CW.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.CW.1/Default
    Condition: EnablePCICW1Condition
  PCIPCIEC21:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.EC2.1
      Content: |
        description: |
          ### Document Name - SHARR-PCI_3.2.1_EC2.1
          ## What does this document do?
          This document changes all public EC2 snapshots to private

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [PCI EC2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.EC2.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
              - Name: TestMode
                Selector: $.Payload.testmode
                Type: Boolean
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                resource_index: 2
                expected_control_id:
                - 'PCI.EC2.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-MakeEBSSnapshotsPrivate
              RuntimeParameters:
                AccountId: '{{ParseInput.AccountId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-MakeEBSSnapshotsPrivate'
                TestMode: '{{ParseInput.TestMode}}'
            isEnd: false

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'EBS Snapshot modified to private'
                UpdatedBy: 'SHARR-PCI_3.2.1_EC2.1'
              Workflow:
                Status: 'RESOLVED'
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.EC2.1/Default
    Condition: EnablePCIEC21Condition
  PCIPCIEC22:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.EC2.2
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_EC2.2

          ## What does this document do?
          This document deletes ingress and egress rules from default security
          group using the AWS SSM Runbook AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output from AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules SSM doc

          ## Documentation Links
          * [PCI EC2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-2)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.EC2.2 finding
          RemediationRoleName:
            type: String
            default: "SO0111-RemoveVPCDefaultSecurityGroupRules"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:security-group/(sg-[0-9a-f]*)$'
                expected_control_id:
                - 'PCI.EC2.2'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RemoveVPCDefaultSecurityGroupRules
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                GroupId: '{{ParseInput.GroupId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: Removed rules on default security group
                UpdatedBy: SHARR-PCI_3.2.1_EC2.2
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.EC2.2/Default
    Condition: EnablePCIEC22Condition
  PCIPCIEC25:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.EC2.5
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_EC2.5

          ## What does this document do?
          Removes public access to remove server administrative ports from an EC2 Security Group

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of AWS-DisablePublicAccessForSecurityGroup runbook.

          ## Documentation Links
          * [PCI v3.2.1 EC2.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-5)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.EC2.5 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-[0-9]):[0-9]{12}:security-group/(sg-[a-f0-9]{8,17})$'
                expected_control_id: [ 'PCI.EC2.5' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: AWS-DisablePublicAccessForSecurityGroup
              RuntimeParameters:
                GroupId: '{{ ParseInput.GroupId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-DisablePublicAccessForSecurityGroup'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Disabled public access to administrative ports in the security group {{ ParseInput.GroupId }}.'
                UpdatedBy: 'SHARR-PCI_3.2.1_EC2.5'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.EC2.5/Default
    Condition: EnablePCIEC25Condition
  PCIPCIIAM8:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.IAM.8
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_PCI.IAM.8

          ## What does this document do?
          This document establishes a default password policy.

          ## Security Standards and Controls
          * CIS 1.5 - 1.11
          * AFSBP IAM.7
          * PCI IAM.8

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI IAM.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-iam-8)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.IAM.8 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id: [ 'PCI.IAM.8' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-SetIAMPasswordPolicy
              RuntimeParameters:
                AllowUsersToChangePassword: True
                HardExpiry: True
                MaxPasswordAge: 90
                MinimumPasswordLength: 14
                RequireSymbols: True
                RequireNumbers: True
                RequireUppercaseCharacters: True
                RequireLowercaseCharacters: True
                PasswordReusePrevention: 24
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetIAMPasswordPolicy'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Established a baseline password policy using the AWSConfigRemediation-SetIAMPasswordPolicy runbook.'
                UpdatedBy: 'SHARR-PCI_3.2.1_IAM.8'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.IAM.8/Default
    Condition: EnablePCIIAM8Condition
  PCIPCIKMS1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.KMS.1
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_PCI.KMS.1

          ## What does this document do?
          Enables rotation for customer-managed KMS keys.

          ## Security Standards and Controls
          * CIS 2.8
          * PCI KMS.1

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [PCI v3.2.1 PCI.KMS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-kms-1)
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.KMS.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableKeyRotation"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: KMSKeyId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:key/([A-Za-z0-9-]{36})$'
                expected_control_id:
                - 'PCI.KMS.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableKeyRotation
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                KeyId: '{{ParseInput.KMSKeyId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled KMS Customer Managed Key rotation for {{ParseInput.KMSKeyId}}'
                UpdatedBy: 'SHARR-PCI_3.2.1_PCI.KMS.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.KMS.1/Default
    Condition: EnablePCIKMS1Condition
  PCIPCILambda1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.Lambda.1
      Content: |
        description: |
          ### Document Name - SHARR-PCI_3.2.1_Lambda.1

          ## What does this document do?
          This document removes the public resource policy. A public resource policy
          contains a principal "*" or AWS: "*", which allows public access to the
          function. The remediation is to remove the SID of the public policy.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [PCI Lambda.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-lambda-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.Lambda.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-RemoveLambdaPublicAccess"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: FunctionName
                Selector: $.Payload.resource_id
                Type: String
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-us-gov|aws-cn):lambda:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:function:([a-zA-Z0-9\-_]{1,64})$'
                expected_control_id:
                - 'PCI.Lambda.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RemoveLambdaPublicAccess
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                FunctionName: '{{ ParseInput.FunctionName }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Lamdba {{ParseInput.FunctionName}} policy updated to remove public access'
                UpdatedBy: 'SHARR-PCI_3.2.1_Lambda.1 '
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.Lambda.1/Default
    Condition: EnablePCILambda1Condition
  PCIPCIRDS1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.RDS.1
      Content: |
        description: |
          ### Document Name - SHARR-PCI_3.2.1_RDS.1
          ## What does this document do?
          This document changes public RDS snapshot to private

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [PCI RDS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-rds-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.RDS.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-MakeRDSSnapshotPrivate"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: DBSnapshotId
                Selector: $.Payload.resource_id
                Type: String
              - Name: DBSnapshotType
                Selector: $.Payload.matches[0]
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: Type
                Selector: $.Payload.type
                Type: String
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(cluster-snapshot|snapshot):([a-zA-Z](?:[0-9a-zA-Z]+[-]{1})*[0-9a-zA-Z]{1,})$'
                resource_index: 2
                expected_control_id:
                - 'PCI.RDS.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            nextStep: Remediation

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-MakeRDSSnapshotPrivate
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                DBSnapshotId: '{{ParseInput.DBSnapshotId}}'
                DBSnapshotType: '{{ParseInput.DBSnapshotType}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
            nextStep: UpdateFinding

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: RDS DB Snapshot modified to private
                UpdatedBy: SHARR-PCI_3.2.1_RDS.1
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.RDS.1/Default
    Condition: EnablePCIRDS1Condition
  PCIPCIRDS2:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.RDS.2
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        description: |
          ### Document Name - SHARR-PCI_3.2.1_RDS.2
          ## What does this document do?
          This document disables public access to RDS instances by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [PCI RDS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-rds-2)
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the PCI.RDS.2 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-DisablePublicAccessToRDSInstance'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:db:((?!.*--.*)(?!.*-$)[a-z][a-z0-9-]{0,62})$'
              expected_control_id:
              - 'PCI.RDS.2'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'DbiResourceId'
            Selector: '$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-DisablePublicAccessToRDSInstance'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              DbiResourceId: '{{ParseInput.DbiResourceId}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Disabled public access to RDS instance'
              UpdatedBy: 'SHARR-PCI_3.2.1_RDS.2'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.RDS.2/Default
    Condition: EnablePCIRDS2Condition
  PCIPCIRedshift1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.Redshift.1
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        description: |
          ### Document Name - SHARR-PCI_3.2.1_Redshift.1
          ## What does this document do?
          This document disables public access to a Redshift cluster by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [PCI Redshift.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-redshift-1)
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the PCI.Redshift.1 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-DisablePublicAccessToRedshiftCluster'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$'
              expected_control_id:
              - 'PCI.Redshift.1'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'ClusterIdentifier'
            Selector: '$.Payload.resource_id'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-DisablePublicAccessToRedshiftCluster'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              ClusterIdentifier: '{{ParseInput.ClusterIdentifier}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Disabled public access to Redshift cluster'
              UpdatedBy: 'SHARR-PCI_3.2.1_Redshift.1'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.Redshift.1/Default
    Condition: EnablePCIRedshift1Condition
  PCIPCICloudTrail1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.CloudTrail.1
      Content: |
        description: |
          ### Document Name - SHARR-PCI_3.2.1_CloudTrail.1
          ## What does this document do?
          This document enables SSE KMS encryption for log files using the SHARR remediation KMS CMK
          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output - Output from the remediation

          ## Documentation Links
          * [PCI CloudTrail.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.CloudTrail.1 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: TrailArn
                Selector: $.Payload.resource_id
                Type: String
              - Name: TrailRegion
                Selector: $.Payload.resource_region
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'PCI.CloudTrail.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableCloudTrailEncryption
              RuntimeParameters:
                TrailRegion: '{{ParseInput.TrailRegion}}'
                TrailArn: '{{ParseInput.TrailArn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableCloudTrailEncryption'
                KMSKeyArn: '{{KMSKeyArn}}'
            isEnd: false

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: Encryption enabled on CloudTrail
                UpdatedBy: SHARR-PCI_3.2.1_CloudTrail.1
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.CloudTrail.1/Default
    Condition: EnablePCICloudTrail1Condition
  PCIPCIEC26:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.EC2.6
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_PCI.EC2.6

          ## What does this document do?
          Enables VPC Flow Logs for a VPC

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [PCI EC2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-ec2-6)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.EC2.6 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableVPCFlowLogs"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: VPC
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\d{12}:vpc/(vpc-[0-9a-f]{8,17}$)'
                expected_control_id:
                - 'PCI.EC2.6'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableVPCFlowLogs
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                VPC: '{{ParseInput.VPC}}'
                RemediationRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs-remediationRole'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled VPC Flow Logs for {{ParseInput.VPC}}'
                UpdatedBy: 'SHARR-PCI_3.2.1_PCI.EC2.6'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.EC2.6/Default
    Condition: EnablePCIEC26Condition
  PCIPCICloudTrail3:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.CloudTrail.3
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_CloudTrail.3

          ## What does this document do?
          This document enables CloudTrail log file validation.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI CloudTrail.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-3)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.CloudTrail.3 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCloudTrailLogFileValidation"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: TrailName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:trail/([A-Za-z0-9._-]{3,128})$'
                expected_control_id:
                - 'PCI.CloudTrail.3'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableCloudTrailLogFileValidation
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                TrailName: '{{ParseInput.TrailName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled CloudTrail log file validation.'
                UpdatedBy: 'SHARR-PCI_3.2.1_CloudTrail.3'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.CloudTrail.3/Default
    Condition: EnablePCICloudTrail3Condition
  PCIPCICloudTrail4:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.CloudTrail.4
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_CloudTrail.4

          ## What does this document do?
          This document configures CloudTrail to log to CloudWatch Logs.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

           ## Documentation Links
          * [PCI CloudTrail.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-cloudtrail-4)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.CloudTrail.4 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCloudTrailToCloudWatchLogging"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: TrailName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:trail/([A-Za-z0-9._-]{3,128})$'
                expected_control_id:
                - 'PCI.CloudTrail.4'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableCloudTrailToCloudWatchLogging
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                TrailName: '{{ ParseInput.TrailName }}'
                CloudWatchLogsRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CloudTrailToCloudWatchLogs'
                LogGroupName: 'CloudTrail/{{ParseInput.TrailName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ParseInput.TrailName}}'
                UpdatedBy: 'SHARR-PCI_3.2.1_CloudTrail.4'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.CloudTrail.4/Default
    Condition: EnablePCICloudTrail4Condition
  PCIPCIConfig1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.Config.1
      Content: |
        description: |
          ### Document Name - SHARR-PCI_3.2.1_Config.1
          ## What does this document do?
          Enables AWS Config:
          * Turns on recording for all resources.
          * Creates an encrypted bucket for Config logging.
          * Creates a logging bucket for access logs for the config bucket
          * Creates an SNS topic for Config notifications
          * Creates a service-linked role

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [PCI Config.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-config-1)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.Config.1 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for remediations
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AWSPartition
                Selector: $.Payload.partition
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'PCI.Config.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableAWSConfig
              RuntimeParameters:
                SNSTopicName: 'SO0111-SHARR-AWSConfigNotification'
                KMSKeyArn: '{{KMSKeyArn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAWSConfig'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'AWS Config enabled'
                UpdatedBy: 'SHARR-PCI_3.2.1_Config.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.Config.1/Default
    Condition: EnablePCIConfig1Condition
  PCIPCIS31:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.S3.1
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_S3.1

          ## What does this document do?
          This document blocks public access to an S3 bucket.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI v3.2.1 S3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-1)
          * [PCI v3.2.1 S3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-2)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.S3.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'PCI.S3.1', 'PCI.S3.2' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-ConfigureS3BucketPublicAccessBlock
              RuntimeParameters:
                BucketName: '{{ParseInput.BucketName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketPublicAccessBlock'
                RestrictPublicBuckets: true
                BlockPublicAcls: true
                IgnorePublicAcls: true
                BlockPublicPolicy: true

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Disabled public access to S3 bucket.'
                UpdatedBy: 'SHARR-PCI_3.2.1_S3.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.S3.1/Default
    Condition: EnablePCIS31Condition
  PCIPCIS34:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.S3.4
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_PCI.S3.4

          ## What does this document do?
          This document enables AES-256 as the default encryption for an S3 bucket.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI v3.2.1 S3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-4)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.S3.4 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
              type: String
              default: "SO0111-EnableDefaultEncryptionS3"
              allowedPattern: '^[\w+=,.@-]+'
          KmsKeyAlias:
              type: String
              description: (Required) KMS Customer-Managed Key (CMK) alias or the default value which is created in the SSM parameter at solution deployment (default-s3-encryption) is used to identify that the s3 bucket encryption value should be set to AES-256.
              default: >-
                {{ssm:/Solutions/SO0111/afsbp/1.0.0/S3.4/KmsKeyAlias}}
              allowedPattern: '^$|^[a-zA-Z0-9/_-]{1,256}$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'PCI.S3.4' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableDefaultEncryptionS3
              RuntimeParameters:
                AccountId: '{{ParseInput.AccountId}}'
                BucketName: '{{ParseInput.BucketName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
                KmsKeyAlias: '{{KmsKeyAlias}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled default encryption for {{ParseInput.BucketName}}'
                UpdatedBy: 'SHARR-PCI_3.2.1_PCI.S3.4'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.S3.4/Default
    Condition: EnablePCIS34Condition
  PCIPCIS35:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.S3.5
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_PCI.S3.5

          ## What does this document do?
          This document adds a bucket policy to restrict internet access to https only.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI v3.2.1 S3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-5)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.S3.5 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'PCI.S3.5' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-SetSSLBucketPolicy
              RuntimeParameters:
                BucketName: '{{ParseInput.BucketName}}'
                AccountId: '{{ParseInput.AccountId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetSSLBucketPolicy'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Added SSL-only access policy to S3 bucket.'
                UpdatedBy: 'SHARR-PCI_3.2.1_PCI.S3.5'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.S3.5/Default
    Condition: EnablePCIS35Condition
  PCIPCIS36:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-PCI_3.2.1_PCI.S3.6
      Content: |+
        description: |
          ### Document Name - SHARR-PCI_3.2.1_S3.6

          ## What does this document do?
          This document blocks public access to all buckets by default at the account level.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [PCI v3.2.1 S3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-pci-controls.html#pcidss-s3-6)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the PCI.S3.6 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id: [ 'PCI.S3.6' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-ConfigureS3PublicAccessBlock
              RuntimeParameters:
                AccountId: '{{ParseInput.AccountId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3PublicAccessBlock'
                RestrictPublicBuckets: true
                BlockPublicAcls: true
                IgnorePublicAcls: true
                BlockPublicPolicy: true

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Configured the account to block public S3 access.'
                UpdatedBy: 'SHARR-PCI_3.2.1_S3.6'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: PCI321MemberStack/PCI PCI.S3.6/Default
    Condition: EnablePCIS36Condition

