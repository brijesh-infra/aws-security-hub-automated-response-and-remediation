Description: (SO0111C) AWS Security Hub Automated Response & Remediation AFSBP 1.0.0 Compliance Pack - Member Account, v1.50.mybuild
AWSTemplateFormatVersion: "2010-09-09"
Parameters:
  SecHubAdminAccount:
    Type: String
    AllowedPattern: \d{12}
    Description: Admin account number
  EnableAutoScaling1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control AutoScaling.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableCloudTrail1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableCloudTrail2:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableCloudTrail4:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableCloudTrail5:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control CloudTrail.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableCodeBuild2:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control CodeBuild.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableConfig1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control Config.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableEC21:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableEC22:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableEC26:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableEC27:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control EC2.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableIAM3:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control IAM.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableIAM7:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control IAM.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableIAM8:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control IAM.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableLambda1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control Lambda.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS2:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS4:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS5:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS6:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS7:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS8:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS13:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.13 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRDS16:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control RDS.16 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRedshift1:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRedshift3:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRedshift4:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableRedshift6:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control Redshift.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableS31:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableS32:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableS34:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableS35:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  EnableS36:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for AFSBP version 1.0.0 Control S3.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
Conditions:
  EnableAutoScaling1Condition:
    Fn::Equals:
      - Ref: EnableAutoScaling1
      - Available
  EnableCloudTrail1Condition:
    Fn::Equals:
      - Ref: EnableCloudTrail1
      - Available
  EnableCloudTrail2Condition:
    Fn::Equals:
      - Ref: EnableCloudTrail2
      - Available
  EnableCloudTrail4Condition:
    Fn::Equals:
      - Ref: EnableCloudTrail4
      - Available
  EnableCloudTrail5Condition:
    Fn::Equals:
      - Ref: EnableCloudTrail5
      - Available
  EnableCodeBuild2Condition:
    Fn::Equals:
      - Ref: EnableCodeBuild2
      - Available
  EnableConfig1Condition:
    Fn::Equals:
      - Ref: EnableConfig1
      - Available
  EnableEC21Condition:
    Fn::Equals:
      - Ref: EnableEC21
      - Available
  EnableEC22Condition:
    Fn::Equals:
      - Ref: EnableEC22
      - Available
  EnableEC26Condition:
    Fn::Equals:
      - Ref: EnableEC26
      - Available
  EnableEC27Condition:
    Fn::Equals:
      - Ref: EnableEC27
      - Available
  EnableIAM3Condition:
    Fn::Equals:
      - Ref: EnableIAM3
      - Available
  EnableIAM7Condition:
    Fn::Equals:
      - Ref: EnableIAM7
      - Available
  EnableIAM8Condition:
    Fn::Equals:
      - Ref: EnableIAM8
      - Available
  EnableLambda1Condition:
    Fn::Equals:
      - Ref: EnableLambda1
      - Available
  EnableRDS1Condition:
    Fn::Equals:
      - Ref: EnableRDS1
      - Available
  EnableRDS2Condition:
    Fn::Equals:
      - Ref: EnableRDS2
      - Available
  EnableRDS4Condition:
    Fn::Equals:
      - Ref: EnableRDS4
      - Available
  EnableRDS5Condition:
    Fn::Equals:
      - Ref: EnableRDS5
      - Available
  EnableRDS6Condition:
    Fn::Equals:
      - Ref: EnableRDS6
      - Available
  EnableRDS7Condition:
    Fn::Equals:
      - Ref: EnableRDS7
      - Available
  EnableRDS8Condition:
    Fn::Equals:
      - Ref: EnableRDS8
      - Available
  EnableRDS13Condition:
    Fn::Equals:
      - Ref: EnableRDS13
      - Available
  EnableRDS16Condition:
    Fn::Equals:
      - Ref: EnableRDS16
      - Available
  EnableRedshift1Condition:
    Fn::Equals:
      - Ref: EnableRedshift1
      - Available
  EnableRedshift3Condition:
    Fn::Equals:
      - Ref: EnableRedshift3
      - Available
  EnableRedshift4Condition:
    Fn::Equals:
      - Ref: EnableRedshift4
      - Available
  EnableRedshift6Condition:
    Fn::Equals:
      - Ref: EnableRedshift6
      - Available
  EnableS31Condition:
    Fn::Equals:
      - Ref: EnableS31
      - Available
  EnableS32Condition:
    Fn::Equals:
      - Ref: EnableS32
      - Available
  EnableS34Condition:
    Fn::Equals:
      - Ref: EnableS34
      - Available
  EnableS35Condition:
    Fn::Equals:
      - Ref: EnableS35
      - Available
  EnableS36Condition:
    Fn::Equals:
      - Ref: EnableS36
      - Available
Resources:
  AFSBPAutoScaling1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_AutoScaling.1
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_AutoScaling.1

          ## What does this document do?
          This document enables ELB healthcheck on a given AutoScaling Group using the [UpdateAutoScalingGroup] API.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * HealthCheckGracePeriod: (Optional) Health check grace period when ELB health check is Enabled
          Default: 30 seconds
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP AutoScaling.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-autoscaling-1)


        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the AutoScaling.1 finding
          HealthCheckGracePeriod:
            type: Integer
            default: 30
            description: ELB Health Check Grace Period
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: AutoScalingGroupName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):autoscaling:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:autoScalingGroup:(?i:[0-9a-f]{11}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}):autoScalingGroupName/(.*)$'
                expected_control_id:
                - 'AutoScaling.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableAutoScalingGroupELBHealthCheck
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: 'SO0111-EnableAutoScalingGroupELBHealthCheck'
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAutoScalingGroupELBHealthCheck'
                AutoScalingGroupName: '{{ParseInput.AutoScalingGroupName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'ASG health check type updated to ELB'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_AutoScaling.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP AutoScaling.1/Default
    Condition: EnableAutoScaling1Condition
  AFSBPCloudTrail1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_CloudTrail.1
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_CloudTrail.1
          ## What does this document do?
          Creates a multi-region trail with KMS encryption and enables CloudTrail
          Note: this remediation will create a NEW trail.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [AFSBP CloudTrail.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-1)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the CloudTrail.1 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for this remediation
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                region: '{{global:REGION}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'CloudTrail.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-CreateCloudTrailMultiRegionTrail
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateCloudTrailMultiRegionTrail'
                AWSPartition: '{{global:AWS_PARTITION}}'
          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Multi-region, encrypted AWS CloudTrail successfully created'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_CloudTrail.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP CloudTrail.1/Default
    Condition: EnableCloudTrail1Condition
  AFSBPCloudTrail2:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_CloudTrail.2
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_CloudTrail.2
          ## What does this document do?
          This document enables SSE KMS encryption for log files using the SHARR remediation KMS CMK
          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output - Output from the remediation

          ## Documentation Links
          * [AFSBP CloudTrail.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-2)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the CloudTrail.2 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: TrailArn
                Selector: $.Payload.resource_id
                Type: String
              - Name: TrailRegion
                Selector: $.Payload.resource_region
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'CloudTrail.2'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableCloudTrailEncryption
              RuntimeParameters:
                TrailRegion: '{{ParseInput.TrailRegion}}'
                TrailArn: '{{ParseInput.TrailArn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableCloudTrailEncryption'
                KMSKeyArn: '{{KMSKeyArn}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: Encryption enabled on CloudTrail
                UpdatedBy: SHARR-AFSBP_1.0.0_CloudTrail.2
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP CloudTrail.2/Default
    Condition: EnableCloudTrail2Condition
  AFSBPCloudTrail4:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_CloudTrail.4
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_CloudTrail.4

          ## What does this document do?
          This document enables CloudTrail log file validation.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 CloudTrail.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-4)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the CloudTrail.4 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCloudTrailLogFileValidation"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: TrailName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:trail/([A-Za-z0-9._-]{3,128})$'
                expected_control_id:
                - 'CloudTrail.4'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableCloudTrailLogFileValidation
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                TrailName: '{{ParseInput.TrailName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled CloudTrail log file validation.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_CloudTrail.2.4'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP CloudTrail.4/Default
    Condition: EnableCloudTrail4Condition
  AFSBPCloudTrail5:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_CloudTrail.5
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_CloudTrail.5

          ## What does this document do?
          This document configures CloudTrail to log to CloudWatch Logs.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [AFSBP v1.0.0 CloudTrail.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-cloudtrail-5)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the CloudTrail.5 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCloudTrailToCloudWatchLogging"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: TrailName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:trail/([A-Za-z0-9._-]{3,128})$'
                expected_control_id:
                - 'CloudTrail.5'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableCloudTrailToCloudWatchLogging
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                TrailName: '{{ ParseInput.TrailName }}'
                CloudWatchLogsRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CloudTrailToCloudWatchLogs'
                LogGroupName: 'CloudTrail/{{ParseInput.TrailName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ParseInput.TrailName}}'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_CloudTrail.5'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP CloudTrail.5/Default
    Condition: EnableCloudTrail5Condition
  AFSBPCodeBuild2:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_CodeBuild.2
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_CodeBuild.2

          ## What does this document do?
          This document removes CodeBuild project environment variables containing clear text credentials and replaces them with Amazon EC2 Systems Manager Parameters.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 CodeBuild.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-codebuild-2)
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the CodeBuild.2 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: ProjectName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):codebuild:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:project/([A-Za-z0-9][A-Za-z0-9\-_]{1,254})$'
                expected_control_id: [ 'CodeBuild.2' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-ReplaceCodeBuildClearTextCredentials
              RuntimeParameters:
                ProjectName: '{{ ParseInput.ProjectName }}'
                AutomationAssumeRole: 'arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/SO0111-ReplaceCodeBuildClearTextCredentials'
          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ ParseInput.FindingId }}'
                ProductArn: '{{ ParseInput.ProductArn }}'
              Note:
                Text: 'Replaced clear text credentials with SSM parameters.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_CodeBuild.2'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP CodeBuild.2/Default
    Condition: EnableCodeBuild2Condition
  AFSBPConfig1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_Config.1
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_Config.1
          ## What does this document do?
          Enables AWS Config:
          * Turns on recording for all resources.
          * Creates an encrypted bucket for Config logging.
          * Creates a logging bucket for access logs for the config bucket
          * Creates an SNS topic for Config notifications
          * Creates a service-linked role

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [AFSBP Config.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-config-1)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the Config.1 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for remediations
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'Config.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableAWSConfig
              RuntimeParameters:
                SNSTopicName: 'SO0111-SHARR-AWSConfigNotification'
                KMSKeyArn: '{{KMSKeyArn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAWSConfig'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'AWS Config enabled'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_Config.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP Config.1/Default
    Condition: EnableConfig1Condition
  AFSBPEC21:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_EC2.1
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_EC2.1
          ## What does this document do?
          This document changes all public EC2 snapshots to private

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [AFSBP EC2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the EC2.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
              - Name: TestMode
                Selector: $.Payload.testmode
                Type: Boolean
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                resource_index: 2
                expected_control_id:
                - 'EC2.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-MakeEBSSnapshotsPrivate
              RuntimeParameters:
                AccountId: '{{ParseInput.AccountId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-MakeEBSSnapshotsPrivate'
                TestMode: '{{ParseInput.TestMode}}'
            isEnd: false

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'EBS Snapshot modified to private'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_EC2.1'
              Workflow:
                Status: 'RESOLVED'
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP EC2.1/Default
    Condition: EnableEC21Condition
  AFSBPEC22:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_EC2.2
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_EC2.2

          ## What does this document do?
          This document deletes ingress and egress rules from default security
          group using the AWS SSM Runbook AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output from AWSConfigRemediation-RemoveVPCDefaultSecurityGroupRules SSM doc

          ## Documentation Links
          * [AFSBP EC2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-2)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the EC2.2 finding
          RemediationRoleName:
            type: String
            default: "SO0111-RemoveVPCDefaultSecurityGroupRules"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:security-group/(sg-[0-9a-f]*)$'
                expected_control_id:
                - 'EC2.2'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-RemoveVPCDefaultSecurityGroupRules
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                GroupId: '{{ParseInput.GroupId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: Removed rules on default security group
                UpdatedBy: SHARR-AFSBP_1.0.0_EC2.2
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP EC2.2/Default
    Condition: EnableEC22Condition
  AFSBPEC26:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_EC2.6
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_EC2.6

          ## What does this document do?
          Enables VPC Flow Logs for a VPC

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [AFSBP EC2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-6)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the EC2.6 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableVPCFlowLogs"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: VPC
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\d{12}:vpc/(vpc-[0-9a-f]{8,17})$'
                expected_control_id:
                - 'EC2.6'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableVPCFlowLogs
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                VPC: '{{ParseInput.VPC}}'
                RemediationRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs-remediationRole'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled VPC Flow Logs for {{ParseInput.VPC}}'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_EC2.6'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP EC2.6/Default
    Condition: EnableEC26Condition
  AFSBPEC27:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_EC2.7
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_EC2.7
          ## What does this document do?
          This document enables `EBS Encryption by default` for an AWS account in the current region by calling another SSM document
          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP EC2.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-ec2-7)
        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the EC2.7 finding
          RemediationRoleName:
            type: String
            default: "SO0111-EnableEbsEncryptionByDefault"
            allowedPattern: '^[\w+=,.@-]+'

        outputs:
          - ExecRemediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'EC2.7'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          -
            name: ExecRemediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableEbsEncryptionByDefault
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled EBS encryption by default'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_EC2.7'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP EC2.7/Default
    Condition: EnableEC27Condition
  AFSBPIAM3:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_IAM.3
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_IAM.3

          ## What does this document do?
          This document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 IAM.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-3)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the IAM.3 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          MaxCredentialUsageAge:
            type: String
            description: (Required) Maximum number of days a key can be unrotated. The default value is 90 days.
            allowedPattern: ^[1-9][0-9]{0,3}|10000$
            default: "90"
          RemediationRoleName:
            type: String
            default: "SO0111-RevokeUnrotatedKeys"
            allowedPattern: '^[\w+=,.@-]+'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: IAMUser
                Selector: $.Payload.resource_id
                Type: String
              - Name: IAMResourceId
                Selector: $.Payload.details.AwsIamUser.UserId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):iam::\d{12}:user(?:(?:\u002F)|(?:\u002F[\u0021-\u007F]{1,510}\u002F))([\w+=,.@-]{1,64})$'
                expected_control_id:
                - 'IAM.3'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RevokeUnrotatedKeys
              RuntimeParameters:
                IAMResourceId: '{{ ParseInput.IAMResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
                MaxCredentialUsageAge: '{{MaxCredentialUsageAge}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Deactivated unrotated keys for {{ ParseInput.IAMUser }}.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_IAM.3'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP IAM.3/Default
    Condition: EnableIAM3Condition
  AFSBPIAM7:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_IAM.7
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_IAM.7

          ## What does this document do?
          This document establishes a default password policy.

          ## Security Standards and Controls
          * AFSBP IAM.7

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP IAM.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-7)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the IAM.7 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id: [ 'IAM.7' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-SetIAMPasswordPolicy
              RuntimeParameters:
                AllowUsersToChangePassword: True
                HardExpiry: True
                MaxPasswordAge: 90
                MinimumPasswordLength: 14
                RequireSymbols: True
                RequireNumbers: True
                RequireUppercaseCharacters: True
                RequireLowercaseCharacters: True
                PasswordReusePrevention: 24
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetIAMPasswordPolicy'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Established a baseline password policy using the AWSConfigRemediation-SetIAMPasswordPolicy runbook.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_IAM.7'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP IAM.7/Default
    Condition: EnableIAM7Condition
  AFSBPIAM8:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_IAM.8
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_IAM.8

          ## What does this document do?
          This document ensures that credentials unused for 90 days or greater are disabled.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of remediation runbook

          SEE AWSConfigRemediation-RevokeUnusedIAMUserCredentials

          ## Documentation Links
          * [AFSBP IAM.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-iam-8)


        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the IAM.8 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: IAMResourceId
                Selector: $.Payload.details.AwsIamUser.UserId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'IAM.8'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RevokeUnusedIAMUserCredentials
              RuntimeParameters:
                IAMResourceId: '{{ ParseInput.IAMResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-RevokeUnusedIAMUserCredentials'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Deactivated unused keys and expired logins using the AWSConfigRemediation-RevokeUnusedIAMUserCredentials runbook.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_IAM.8'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP IAM.8/Default
    Condition: EnableIAM8Condition
  AFSBPLambda1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_Lambda.1
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_Lambda.1

          ## What does this document do?
          This document removes the public resource policy. A public resource policy
          contains a principal "*" or AWS: "*", which allows public access to the
          function. The remediation is to remove the SID of the public policy.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [AFSBP Lambda.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-lambda-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the Lambda.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-RemoveLambdaPublicAccess"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: FunctionName
                Selector: $.Payload.resource_id
                Type: String
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-us-gov|aws-cn):lambda:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:function:([a-zA-Z0-9\-_]{1,64})$'
                expected_control_id:
                - 'Lambda.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-RemoveLambdaPublicAccess
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                FunctionName: '{{ ParseInput.FunctionName }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Lamdba {{ParseInput.FunctionName}} policy updated to remove public access'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_Lambda.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP Lambda.1/Default
    Condition: EnableLambda1Condition
  AFSBPRDS1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.1
      Content: |
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.1
          ## What does this document do?
          This document changes public RDS snapshot to private

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [AFSBP RDS.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-1)
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the RDS.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-MakeRDSSnapshotPrivate"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: DBSnapshotId
                Selector: $.Payload.resource_id
                Type: String
              - Name: DBSnapshotType
                Selector: $.Payload.matches[0]
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: Type
                Selector: $.Payload.type
                Type: String
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(cluster-snapshot|snapshot):([a-zA-Z](?:[0-9a-zA-Z]+[-]{1})*[0-9a-zA-Z]{1,})$'
                resource_index: 2
                expected_control_id:
                - 'RDS.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            nextStep: Remediation

          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-MakeRDSSnapshotPrivate
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                DBSnapshotId: '{{ParseInput.DBSnapshotId}}'
                DBSnapshotType: '{{ParseInput.DBSnapshotType}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
            nextStep: UpdateFinding

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: RDS DB Snapshot modified to private
                UpdatedBy: SHARR-AFSBP_1.0.0_RDS.1
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.1/Default
    Condition: EnableRDS1Condition
  AFSBPRDS2:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.2
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.2
          ## What does this document do?
          This document disables public access to RDS instances by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [AFSBP RDS.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-2)
        schemaVersion: '0.3'
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the RDS.2 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-DisablePublicAccessToRDSInstance'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:db:((?!.*--.*)(?!.*-$)[a-z][a-z0-9-]{0,62})$'
              expected_control_id:
              - 'RDS.2'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'DbiResourceId'
            Selector: '$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-DisablePublicAccessToRDSInstance'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              DbiResourceId: '{{ParseInput.DbiResourceId}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Disabled public access to RDS instance'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.2'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.2/Default
    Condition: EnableRDS2Condition
  AFSBPRDS4:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.4
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.4

          ## What does this document do?
          This document encrypts an unencrypted RDS snapshot by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.
          * KMSKeyId: (Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.

          ## Documentation Links
          * [AFSBP RDS.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-4)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the RDS.4 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-EncryptRDSSnapshot'
            allowedPattern: '^[\w+=,.@/-]+'
          KMSKeyId:
            type: 'String'
            default: 'alias/aws/rds'
            description: '(Optional) ID, ARN or Alias for the AWS KMS Customer-Managed Key (CMK) to use to encrypt the snapshot.'
            allowedPattern: '^(?:arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:)?(?:(?:alias/[A-Za-z0-9/_-]+)|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          outputs:
          - Name: 'SourceDBSnapshotIdentifier'
            Selector: '$.Payload.matches[1]'
            Type: 'String'
          - Name: 'SourceDBSnapshotIdentifierNoPrefix'
            Selector: '$.Payload.matches[2]'
            Type: 'String'
          - Name: 'DBSnapshotType'
            Selector: '$.Payload.matches[0]'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):rds:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:((?:cluster-)?snapshot|dbclustersnapshot):((?:rds:)?((?!.*--.*)(?!.*-$)[a-zA-Z][a-zA-Z0-9-]{0,254}))$'
              resource_index: 2
              expected_control_id:
              - 'RDS.4'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-EncryptRDSSnapshot'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              SourceDBSnapshotIdentifier: '{{ParseInput.SourceDBSnapshotIdentifier}}'
              TargetDBSnapshotIdentifier: '{{ParseInput.SourceDBSnapshotIdentifierNoPrefix}}-encrypted'
              DBSnapshotType: '{{ParseInput.DBSnapshotType}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
              KmsKeyId: '{{KMSKeyId}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Encrypted RDS snapshot'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.4'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.4/Default
    Condition: EnableRDS4Condition
  AFSBPRDS5:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.5
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.RDS.5

          ## What does this document do?
          This document configures an RDS DB instance for multiple Availability Zones by calling another SSM document.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [AFSBP RDS.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-5)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the RDS.5 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-EnableMultiAZOnRDSInstance'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: ''
              expected_control_id:
              - 'RDS.5'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'DbInstanceResourceId'
            Selector: '$.Payload.details.AwsRdsDbInstance.DbiResourceId'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-EnableMultiAZOnRDSInstance'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              DbiResourceId: '{{ParseInput.DbInstanceResourceId}}'
              ApplyImmediately: true
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Configured RDS cluster for multiple Availability Zones'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.5'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.5/Default
    Condition: EnableRDS5Condition
  AFSBPRDS6:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.6
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.6

          ## What does this document do?
          This document enables `Enhanced Monitoring` on a given Amazon RDS instance by calling another SSM document.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * VerifyRemediation.Output - The standard HTTP response from the ModifyDBInstance API.
          ## Documentation Links

          * [AFSBP RDS.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-6)
        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the RDS.6 finding
          RemediationRoleName:
            type: String
            default: "SO0111-EnableEnhancedMonitoringOnRDSInstance"
            allowedPattern: '^[\w+=,.@-]+'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: ResourceId
                Selector: $.Payload.details.AwsRdsDbInstance.DbiResourceId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'RDS.6'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

            isEnd: false
          -
            name: GetMonitoringRoleArn
            action: aws:executeAwsApi
            description: |
              ## GetRole API to get EnhancedMonitoring IAM role ARN
            timeoutSeconds: 600
            isEnd: false
            inputs:
              Service: iam
              Api: GetRole
              RoleName: 'SO0111-RDSMonitoring-remediationRole'
            outputs:
            - Name: Arn
              Selector: $.Role.Arn
              Type: String

          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableEnhancedMonitoringOnRDSInstance
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                ResourceId: '{{ ParseInput.ResourceId }}'
                MonitoringRoleArn: '{{GetMonitoringRoleArn.Arn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enhanced Monitoring enabled on RDS DB cluster'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.6'
              Workflow:
                Status: 'RESOLVED'
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.6/Default
    Condition: EnableRDS6Condition
  AFSBPRDS7:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.7
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.7

          ## What does this document do?
          This document enables `Deletion Protection` on a given Amazon RDS cluster by calling another SSM document.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - The standard HTTP response from the ModifyDBCluster API.

          ## Documentation Links
          * [AFSBP RDS.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-7)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the RDS.7 finding
          RemediationRoleName:
            type: String
            default: "SO0111-EnableRDSClusterDeletionProtection"
            allowedPattern: '^[\w+=,.@-]+'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: ResourceId
                Selector: $.Payload.details.AwsRdsDbCluster.DbClusterResourceId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'RDS.7'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableRDSClusterDeletionProtection
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                ClusterId: '{{ ParseInput.ResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Deletion protection enabled on RDS DB cluster'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.7'
              Workflow:
                Status: 'RESOLVED'
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.7/Default
    Condition: EnableRDS7Condition
  AFSBPRDS8:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.8
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.RDS.8

          ## What does this document do?
          This document enables `Deletion Protection` on a given Amazon RDS cluster by calling another SSM document.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [AFSBP RDS.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-8)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the RDS.8 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-EnableRDSInstanceDeletionProtection'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: ''
              expected_control_id:
              - 'RDS.8'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'DbInstanceResourceId'
            Selector: '$.Payload.details.AwsRdsDbInstance.DbiResourceId'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-EnableRDSInstanceDeletionProtection'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              DbInstanceResourceId: '{{ParseInput.DbInstanceResourceId}}'
              ApplyImmediately: true
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Enabled deletion protection on RDS instance'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.8'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.8/Default
    Condition: EnableRDS8Condition
  AFSBPRDS13:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.13
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.13

          ## What does this document do?
          This document enables `Auto minor version upgrade` on a given Amazon RDS instance by calling another SSM document.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - The standard HTTP response from the ModifyDBInstance API.

          ## Documentation Links
          * [AFSBP RDS.13](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-13)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the RDS.13 finding
          RemediationRoleName:
            type: String
            default: "SO0111-EnableMinorVersionUpgradeOnRDSDBInstance"
            allowedPattern: '^[\w+=,.@-]+'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: 'DbiResourceId'
                Selector: '$.Payload.resource.Details.AwsRdsDbInstance.DbiResourceId'
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'RDS.13'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableMinorVersionUpgradeOnRDSDBInstance
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                DbiResourceId: '{{ ParseInput.DbiResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Minor Version enabled on the RDS Instance.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.13'
              Workflow:
                Status: 'RESOLVED'
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.13/Default
    Condition: EnableRDS13Condition
  AFSBPRDS16:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_RDS.16
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_RDS.16

          ## What does this document do?
          This document enables `Copy tags to snapshots` on a given Amazon RDS cluster by calling another SSM document.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - The standard HTTP response from the ModifyDBCluster API.

          ## Documentation Links
          * [AFSBP RDS.16](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-rds-16)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the RDS.16 finding
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCopyTagsToSnapshotOnRDSCluster"
            allowedPattern: '^[\w+=,.@-]+'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: DbClusterResourceId
                Selector: $.Payload.details.AwsRdsDbCluster.DbClusterResourceId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - 'RDS.16'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableCopyTagsToSnapshotOnRDSCluster
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                DbClusterResourceId: '{{ ParseInput.DbClusterResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
                ApplyImmediately: true

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Copy Tags to Snapshots enabled on RDS DB cluster'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_RDS.16'
              Workflow:
                Status: 'RESOLVED'
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP RDS.16/Default
    Condition: EnableRDS16Condition
  AFSBPRedshift1:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_Redshift.1
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_Redshift.1

          ## What does this document do?
          This document disables public access to a Redshift cluster by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [AFSBP Redshift.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-1)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the Redshift.1 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-DisablePublicAccessToRedshiftCluster'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$'
              expected_control_id:
              - 'Redshift.1'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'ClusterIdentifier'
            Selector: '$.Payload.resource_id'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-DisablePublicAccessToRedshiftCluster'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              ClusterIdentifier: '{{ParseInput.ClusterIdentifier}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Disabled public access to Redshift cluster'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_Redshift.1'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP Redshift.1/Default
    Condition: EnableRedshift1Condition
  AFSBPRedshift3:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_Redshift.3
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_Redshift.3

          ## What does this document do?
          This document enables automatic snapshots on a Redshift cluster by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [AFSBP Redshift.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-3)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the Redshift.3 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-EnableAutomaticSnapshotsOnRedshiftCluster'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$'
              expected_control_id:
              - 'Redshift.3'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'ClusterIdentifier'
            Selector: '$.Payload.resource_id'
            Type: 'String'
          - Name: RetentionPeriodSerialized
            Selector: $.Payload.aws_config_rule.InputParameters
            Type: String
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'ExtractConfigRuleParameters'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              SerializedJson: '{{ParseInput.RetentionPeriodSerialized}}'
            Runtime: 'python3.8'
            Handler: 'event_handler'
            Script: |-
              #!/usr/bin/python
              # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              # SPDX-License-Identifier: Apache-2.0
              import json
              
              def event_handler(event, context):
                  try:
                      return json.loads(event['SerializedJson'])
                  except Exception as e:
                      print(e)
                      exit('Failed to deserialize data')
              
          outputs:
          - Name: 'MinRetentionPeriod'
            Selector: '$.Payload.MinRetentionPeriod'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-EnableAutomaticSnapshotsOnRedshiftCluster'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              ClusterIdentifier: '{{ParseInput.ClusterIdentifier}}'
              MinRetentionPeriod: '{{ExtractConfigRuleParameters.MinRetentionPeriod}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Enabled automatic snapshots on Redshift cluster'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_Redshift.3'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP Redshift.3/Default
    Condition: EnableRedshift3Condition
  AFSBPRedshift4:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_Redshift.4
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_Redshift.4

          ## What does this document do?
          This document disables public access to a Redshift cluster by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [AFSBP Redshift.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-1)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the Redshift.4 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-EnableRedshiftClusterAuditLogging'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$'
              expected_control_id:
              - 'Redshift.4'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'ClusterIdentifier'
            Selector: '$.Payload.resource_id'
            Type: 'String'
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: CheckIfSSMParameterWithS3BucketNameIsAvailable
          action: 'aws:executeScript'
          inputs:
            Runtime: python3.8
            Handler: check_for_s3_bucket_name
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0

              import re
              import json
              import boto3
              from botocore.config import Config

              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)

              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)

              def get_solution_id():
                  return 'SO0111'

              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version

              def check_for_s3_bucket_name(event, context):
                try:
                    ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                    )
                    s3_bucket_name_for_audit_logging = ssm.get_parameter(
                        Name=f'/Solutions/{get_solution_id()}/afsbp/1.0.0/REDSHIFT.4/S3BucketNameForAuditLogging'
                    )['Parameter'].get('Value', 'unknown')
                except Exception as e:
                    return {
                      "s3_bucket_name_for_redshift_audit_logging": "NOT_AVAILABLE"
                    }
                return {
                    "s3_bucket_name_for_redshift_audit_logging": s3_bucket_name_for_audit_logging
                }
          outputs:
            - Name: BucketName
              Selector: $.Payload.s3_bucket_name_for_redshift_audit_logging
              Type: String
        - name: 'ValidateIfS3BucketNameIsConfigured'
          action: aws:branch
          inputs:
            Choices:
            - NextStep: UpdateFindingThatS3BucketNameIsNotConfigured
              Variable: '{{CheckIfSSMParameterWithS3BucketNameIsAvailable.BucketName}}'
              StringEquals: 'NOT_AVAILABLE'
            Default:
              Remediation
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-EnableRedshiftClusterAuditLogging'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              ClusterIdentifier: '{{ParseInput.ClusterIdentifier}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
              BucketName: '{{CheckIfSSMParameterWithS3BucketNameIsAvailable.BucketName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Enabled Audit logging for the Redshift cluster.'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_Redshift.4'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true
        - name: 'UpdateFindingThatS3BucketNameIsNotConfigured'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Remediation failed the s3 bucket name is not available, review the cloudformation template and select the option Yes for create redshift.4 s3 bucket cloudformation parameter.'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_Redshift.4'
            Workflow:
              Status: 'NOTIFIED'
          description: 'Abort remediation as s3 bucket name is unavailable.'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP Redshift.4/Default
    Condition: EnableRedshift4Condition
  AFSBPRedshift6:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_Redshift.6
      Content: |+
        # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
        # SPDX-License-Identifier: Apache-2.0
        ---
        schemaVersion: '0.3'
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_Redshift.6

          ## What does this document do?
          This document enables automatic version upgrade on a Redshift cluster by calling another SSM document

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Optional) The ARN of the role that allows Automation to perform the actions on your behalf.
          * RemediationRoleName: (Optional) The name of the role that allows Automation to remediate the finding on your behalf.

          ## Documentation Links
          * [AFSBP Redshift.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-redshift-6)
        assumeRole: '{{AutomationAssumeRole}}'
        outputs:
        - 'Remediation.Output'
        - 'ParseInput.AffectedObject'
        parameters:
          Finding:
            type: 'StringMap'
            description: 'The input from the Orchestrator Step function for the Redshift.6 finding'
          AutomationAssumeRole:
            type: 'String'
            description: '(Required) The ARN of the role that allows Automation to perform the actions on your behalf.'
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: 'String'
            default: 'SO0111-EnableAutomaticVersionUpgradeOnRedshiftCluster'
            allowedPattern: '^[\w+=,.@/-]+'
        mainSteps:
        - name: 'ParseInput'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              Finding: '{{Finding}}'
              parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):redshift:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:cluster:(?!.*--)([a-z][a-z0-9-]{0,62})(?<!-)$'
              expected_control_id:
              - 'Redshift.6'
            Runtime: 'python3.8'
            Handler: 'parse_event'
            Script: |-
              #!/usr/bin/python
              ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              ## SPDX-License-Identifier: Apache-2.0
              
              import re
              import json
              import boto3
              from botocore.config import Config
              
              def connect_to_config(boto_config):
                  return boto3.client('config', config=boto_config)
              
              def connect_to_ssm(boto_config):
                  return boto3.client('ssm', config=boto_config)
              
              def get_solution_id():
                  return 'SO0111'
              
              def get_solution_version():
                  ssm = connect_to_ssm(
                      Config(
                          retries = {
                              'mode': 'standard'
                          },
                          user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                      )
                  )
                  solution_version = 'unknown'
                  try:
                      ssm_parm_value = ssm.get_parameter(
                          Name=f'/Solutions/{get_solution_id()}/member-version'
                      )['Parameter'].get('Value', 'unknown')
                      solution_version = ssm_parm_value
                  except Exception as e:
                      print(e)
                      print(f'ERROR getting solution version')
                  return solution_version
              
              def get_shortname(long_name):
                  short_name = {
                      'aws-foundational-security-best-practices': 'AFSBP',
                      'cis-aws-foundations-benchmark': 'CIS',
                      'pci-dss': 'PCI'
                  }
                  return short_name.get(long_name, None)
              
              def get_config_rule(rule_name):
                  boto_config = Config(
                      retries = {
                          'mode': 'standard'
                      },
                      user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                  )
                  config_rule = None
                  try:
                      configsvc = connect_to_config(boto_config)
                      config_rule = configsvc.describe_config_rules(
                          ConfigRuleNames=[ rule_name ]
                      ).get('ConfigRules', [])[0]
                  except Exception as e:
                      print(e)
                      exit(f'ERROR getting config rule {rule_name}')
                  return config_rule
              
              class FindingEvent:
                  """
                  Finding object returns the parse fields from an input finding json object
                  """
                  def _get_resource_id(self, parse_id_pattern, resource_index):
                      identifier_raw = self.finding_json['Resources'][0]['Id']
                      self.resource_id = identifier_raw
                      self.resource_id_matches = []
              
                      if parse_id_pattern:
                          identifier_match = re.match(
                              parse_id_pattern,
                              identifier_raw
                          )
              
                          if identifier_match:
                              for group in range(1, len(identifier_match.groups())+1):
                                  self.resource_id_matches.append(identifier_match.group(group))
                              self.resource_id = identifier_match.group(resource_index)
                          else:
                              exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                          return
              
                  def _get_standard_info(self):
                      match_finding_id = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                          self.finding_json['Id']
                      )
                      if match_finding_id:
                          self.standard_id = get_shortname(match_finding_id.group(1))
                          self.standard_version = match_finding_id.group(2)
                          self.control_id = match_finding_id.group(3)      
                      else:
                          self.valid_finding = False
                          self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
              
                  def _get_aws_config_rule(self):
                      # config_rule_id refers to the AWS Config Rule that produced the finding
                      if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                          self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                          self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                      return
                  
                  def _get_region_from_resource_id(self):
                      check_for_region = re.match(
                          r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                          self.finding_json['Resources'][0]['Id']
                      )
                      if check_for_region:
                          self.resource_region = check_for_region.group(1)
              
                  def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                      self.valid_finding = True
                      self.resource_region = None
                      self.control_id = None
                      self.aws_config_rule_id = None
                      self.aws_config_rule = {}
              
                      """Populate fields"""
                      # v1.5
                      self.finding_json = finding_json
                      self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                      self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
              
                      # V1.4
                      self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                      if not re.match(r'^\d{12}$', self.account_id):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                      self.finding_id = self.finding_json.get('Id', None)              # deprecate
                      self.product_arn = self.finding_json.get('ProductArn', None)
                      if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                      self.details = self.finding_json['Resources'][0].get('Details', {})
                      # Test mode is used with fabricated finding data to tell the 
                      # remediation runbook to run in test more (where supported)
                      # Currently not widely-used and perhaps should be deprecated.
                      self.testmode = bool('testmode' in self.finding_json)
                      self.resource = self.finding_json['Resources'][0]
                      self._get_region_from_resource_id()
                      self._get_aws_config_rule()
                      self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
              
                      # Validate control_id   
                      if not self.control_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                      elif self.control_id not in expected_control_id:  # ControlId is the expected value
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
              
                      if not self.resource_id:
                          if self.valid_finding:
                              self.valid_finding = False
                              self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
              
                      if not self.valid_finding:
                          # Error message and return error data
                          msg = f'ERROR: {self.invalid_finding_reason}'
                          exit(msg)
              
                  def __str__(self):
                      return json.dumps(self.__dict__)
              
              '''
              MAIN
              '''
              def parse_event(event, context):
                  finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                
                  if not finding_event.valid_finding:
                      exit('ERROR: Finding is not valid')
              
                  return {
                      "account_id": finding_event.account_id,
                      "resource_id": finding_event.resource_id, 
                      "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                      "control_id": finding_event.control_id,
                      "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                      "object": finding_event.affected_object,
                      "matches": finding_event.resource_id_matches,
                      "details": finding_event.details,               # Deprecate v1.5.0+
                      "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                      "resource": finding_event.resource,
                      "resource_region": finding_event.resource_region,
                      "finding": finding_event.finding_json,
                      "aws_config_rule": finding_event.aws_config_rule
                  }
          outputs:
          - Name: 'ClusterIdentifier'
            Selector: '$.Payload.resource_id'
            Type: 'String'
          - Name: AllowVersionUpgradeSerialized
            Selector: $.Payload.aws_config_rule.InputParameters
            Type: String
          - Name: 'AffectedObject'
            Selector: '$.Payload.object'
            Type: 'StringMap'
          - Name: 'FindingId'
            Selector: '$.Payload.finding.Id'
            Type: 'String'
          - Name: 'ProductArn'
            Selector: '$.Payload.finding.ProductArn'
            Type: 'String'
          - Name: 'RemediationRegion'
            Selector: '$.Payload.resource_region'
            Type: 'String'
          - Name: 'RemediationAccount'
            Selector: '$.Payload.account_id'
            Type: 'String'
        - name: 'ExtractConfigRuleParameters'
          action: 'aws:executeScript'
          inputs:
            InputPayload:
              SerializedJson: '{{ParseInput.AllowVersionUpgradeSerialized}}'
            Runtime: 'python3.8'
            Handler: 'event_handler'
            Script: |-
              #!/usr/bin/python
              # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
              # SPDX-License-Identifier: Apache-2.0
              import json
              
              def event_handler(event, context):
                  try:
                      return json.loads(event['SerializedJson'])
                  except Exception as e:
                      print(e)
                      exit('Failed to deserialize data')
              
          outputs:
          - Name: 'AllowVersionUpgrade'
            Selector: '$.Payload.allowVersionUpgrade'
            Type: 'String'
        - name: 'Remediation'
          action: 'aws:executeAutomation'
          inputs:
            DocumentName: 'SHARR-EnableAutomaticVersionUpgradeOnRedshiftCluster'
            TargetLocations:
              - Accounts:
                - '{{ParseInput.RemediationAccount}}'
                Regions:
                - '{{ParseInput.RemediationRegion}}'
                ExecutionRoleName: '{{RemediationRoleName}}'
            RuntimeParameters:
              ClusterIdentifier: '{{ParseInput.ClusterIdentifier}}'
              AllowVersionUpgrade: '{{ExtractConfigRuleParameters.AllowVersionUpgrade}}'
              AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
        - name: 'UpdateFinding'
          action: 'aws:executeAwsApi'
          inputs:
            Service: 'securityhub'
            Api: 'BatchUpdateFindings'
            FindingIdentifiers:
            - Id: '{{ParseInput.FindingId}}'
              ProductArn: '{{ParseInput.ProductArn}}'
            Note:
              Text: 'Enabled automatic version upgrade on Redshift cluster'
              UpdatedBy: 'SHARR-AFSBP_1.0.0_Redshift.6'
            Workflow:
              Status: 'RESOLVED'
          description: 'Update finding'
          isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP Redshift.6/Default
    Condition: EnableRedshift6Condition
  AFSBPS31:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_S3.1
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_S3.1

          ## What does this document do?
          This document blocks public access to all buckets by default at the account level.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 S3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-1)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the S3.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id: [ 'S3.1' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-ConfigureS3PublicAccessBlock
              RuntimeParameters:
                AccountId: '{{ParseInput.AccountId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3PublicAccessBlock'
                RestrictPublicBuckets: true
                BlockPublicAcls: true
                IgnorePublicAcls: true
                BlockPublicPolicy: true

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Configured the account to block public S3 access.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_S3.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP S3.1/Default
    Condition: EnableS31Condition
  AFSBPS32:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_S3.2
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_S3.2

          ## What does this document do?
          This document blocks all public access to an S3 bucket.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 S3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-2)
          * [AFSBP v1.0.0 S3.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-3)
          * [AFSBP v1.0.0 S3.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-8)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the S3.2 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'S3.2', 'S3.3', 'S3.8' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-ConfigureS3BucketPublicAccessBlock
              RuntimeParameters:
                BucketName: '{{ParseInput.BucketName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketPublicAccessBlock'
                RestrictPublicBuckets: true
                BlockPublicAcls: true
                IgnorePublicAcls: true
                BlockPublicPolicy: true

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Disabled public access to S3 bucket.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_S3.2'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP S3.2/Default
    Condition: EnableS32Condition
  AFSBPS34:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_S3.4
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_S3.4

          ## What does this document do?
          This document enables AES-256 as the default encryption for an S3 bucket.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 S3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-4)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the S3.4 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
              type: String
              default: "SO0111-EnableDefaultEncryptionS3"
              allowedPattern: '^[\w+=,.@-]+'
          KmsKeyAlias:
              type: String
              description: (Required) KMS Customer-Managed Key (CMK) alias or the default value which is created in the SSM parameter at solution deployment (default-s3-encryption) is used to identify that the s3 bucket encryption value should be set to AES-256.
              default: >-
                {{ssm:/Solutions/SO0111/afsbp/1.0.0/S3.4/KmsKeyAlias}}
              allowedPattern: '^$|^[a-zA-Z0-9/_-]{1,256}$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'S3.4' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableDefaultEncryptionS3
              RuntimeParameters:
                AccountId: '{{ParseInput.AccountId}}'
                BucketName: '{{ParseInput.BucketName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
                KmsKeyAlias: '{{KmsKeyAlias}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled default encryption for {{ParseInput.BucketName}}'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_S3.4'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP S3.4/Default
    Condition: EnableS34Condition
  AFSBPS35:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_S3.5
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_S3.5

          ## What does this document do?
          This document adds a bucket policy to restrict internet access to https only.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 S3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-5)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the S3.5 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: AccountId
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'S3.5' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-SetSSLBucketPolicy
              RuntimeParameters:
                BucketName: '{{ParseInput.BucketName}}'
                AccountId: '{{ParseInput.AccountId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetSSLBucketPolicy'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Added SSL-only access policy to S3 bucket.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_S3.5'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP S3.5/Default
    Condition: EnableS35Condition
  AFSBPS36:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-AFSBP_1.0.0_S3.6
      Content: |+
        description: |
          ### Document Name - SHARR-AFSBP_1.0.0_S3.6

          ## What does this document do?
          This document restricts cross-account access to a bucket in the local account.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [AFSBP v1.0.0 S3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-fsbp-controls.html#fsbp-s3-6)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the S3.6 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-S3BlockDenylist"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: FindingId
                Selector: $.Payload.finding.Id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.finding.ProductArn
                Type: String
              - Name: ConfigRuleName
                Selector: $.Payload.aws_config_rule.ConfigRuleName
                Type: String
              - Name: DenyListSerialized
                Selector: $.Payload.aws_config_rule.InputParameters
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id: [ 'S3.6' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          -
            name: ExtractSensitiveApis
            action: 'aws:executeScript'
            inputs:
              InputPayload:
                SerializedList: '{{ ParseInput.DenyListSerialized }}'
              Runtime: python3.8
              Handler: runbook_handler
              Script: |-
                #!/usr/bin/python
                # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                # SPDX-License-Identifier: Apache-2.0
                import json
                
                def runbook_handler(event, context):
                    try:
                        deserialized = json.loads(event['SerializedList'])
                        if 'blacklistedActionPattern' in deserialized:
                            return deserialized['blacklistedActionPattern'] # Returns comma-delimited list in a string
                        else:
                            exit('Missing blacklistedActionPattern in AWS Config data')
                    except Exception as e:
                        print(e)
                        exit('Failed getting comma-delimited string list of sensitive API calls input data')
                
            outputs:
              - Name: ListOfApis
                Selector: $.Payload
                Type: String

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-S3BlockDenylist
              RuntimeParameters:
                BucketName: '{{ParseInput.BucketName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
                DenyList: '{{ExtractSensitiveApis.ListOfApis}}'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Added explicit deny for sensitive bucket access from another account.'
                UpdatedBy: 'SHARR-AFSBP_1.0.0_S3.6'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: AFSBPMemberStack/AFSBP S3.6/Default
    Condition: EnableS36Condition

