Description: (SO0111C) AWS Security Hub Automated Response & Remediation CIS 1.2.0 Compliance Pack - Member Account, v1.50.mybuild
AWSTemplateFormatVersion: "2010-09-09"
Parameters:
  SecHubAdminAccount:
    Type: String
    AllowedPattern: \d{12}
    Description: Admin account number
  Enable13:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 1.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable14:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 1.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable15:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 1.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable21:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable22:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.2 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable23:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable24:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.4 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable25:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.5 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable26:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.6 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable27:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.7 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable28:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.8 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable29:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 2.9 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable31:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 3.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable41:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 4.1 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
  Enable43:
    Type: String
    Default: Available
    AllowedValues:
      - Available
      - NOT Available
    Description: Enable/disable availability of remediation for CIS version 1.2.0 Control 4.3 in Security Hub Console Custom Actions. If NOT Available the remediation cannot be triggered from the Security Hub console in the Security Hub Admin account.
Conditions:
  Enable13Condition:
    Fn::Equals:
      - Ref: Enable13
      - Available
  Enable14Condition:
    Fn::Equals:
      - Ref: Enable14
      - Available
  Enable15Condition:
    Fn::Equals:
      - Ref: Enable15
      - Available
  Enable21Condition:
    Fn::Equals:
      - Ref: Enable21
      - Available
  Enable22Condition:
    Fn::Equals:
      - Ref: Enable22
      - Available
  Enable23Condition:
    Fn::Equals:
      - Ref: Enable23
      - Available
  Enable24Condition:
    Fn::Equals:
      - Ref: Enable24
      - Available
  Enable25Condition:
    Fn::Equals:
      - Ref: Enable25
      - Available
  Enable26Condition:
    Fn::Equals:
      - Ref: Enable26
      - Available
  Enable27Condition:
    Fn::Equals:
      - Ref: Enable27
      - Available
  Enable28Condition:
    Fn::Equals:
      - Ref: Enable28
      - Available
  Enable29Condition:
    Fn::Equals:
      - Ref: Enable29
      - Available
  Enable31Condition:
    Fn::Equals:
      - Ref: Enable31
      - Available
  Enable41Condition:
    Fn::Equals:
      - Ref: Enable41
      - Available
  Enable43Condition:
    Fn::Equals:
      - Ref: Enable43
      - Available
Resources:
  CIS13:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_1.3
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_1.3

          ## What does this document do?
          This document ensures that credentials unused for 90 days or greater are disabled.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of DescribeAutoScalingGroups API.

          ## Documentation Links
          * [CIS v1.2.0 1.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.3)


        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 1.3 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: IAMUser
                Selector: $.Payload.resource_id
                Type: String
              - Name: IAMResourceId
                Selector: $.Payload.details.AwsIamUser.UserId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):iam::\d{12}:user(?:(?:\u002F)|(?:\u002F[\u0021-\u007F]{1,510}\u002F))([\w+=,.@-]{1,64})$'
                expected_control_id:
                - '1.3'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RevokeUnusedIAMUserCredentials
              RuntimeParameters:
                IAMResourceId: '{{ ParseInput.IAMResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-RevokeUnusedIAMUserCredentials'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Deactivated unused keys and expired logins for {{ ParseInput.IAMUser }}.'
                UpdatedBy: 'SHARR-CIS_1.2.0_1.3'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 1.3/Default
    Condition: Enable13Condition
  CIS14:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_1.4
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_1.4

          ## What does this document do?
          This document disables active keys that have not been rotated for more than 90 days. Note that this remediation is **DISRUPTIVE**.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [CIS v1.2.0 1.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.4)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 1.4 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          MaxCredentialUsageAge:
            type: String
            description: (Required) Maximum number of days a key can be unrotated. The default value is 90 days.
            allowedPattern: ^[1-9][0-9]{0,3}|10000$
            default: "90"
          RemediationRoleName:
            type: String
            default: "SO0111-RevokeUnrotatedKeys"
            allowedPattern: '^[\w+=,.@-]+'
        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: IAMUser
                Selector: $.Payload.resource_id
                Type: String
              - Name: IAMResourceId
                Selector: $.Payload.details.AwsIamUser.UserId
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):iam::\d{12}:user(?:(?:\u002F)|(?:\u002F[\u0021-\u007F]{1,510}\u002F))([\w+=,.@-]{1,64})$'
                expected_control_id:
                - '1.4'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RevokeUnrotatedKeys
              RuntimeParameters:
                IAMResourceId: '{{ ParseInput.IAMResourceId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'
                MaxCredentialUsageAge: '{{MaxCredentialUsageAge}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Deactivated unrotated keys for {{ ParseInput.IAMUser }}.'
                UpdatedBy: 'SHARR-CIS_1.2.0_1.4'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 1.4/Default
    Condition: Enable14Condition
  CIS15:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_1.5
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_1.5

          ## What does this document do?
          This document establishes a default password policy.

          ## Security Standards and Controls
          * CIS 1.5 - 1.11

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [CIS v1.2.0 1.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.5)
          * [CIS v1.2.0 1.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.6)
          * [CIS v1.2.0 1.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.7)
          * [CIS v1.2.0 1.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.8)
          * [CIS v1.2.0 1.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.9)
          * [CIS v1.2.0 1.10](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.10)
          * [CIS v1.2.0 1.11](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-1.11)


        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 1.5 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id: [ '1.5', '1.6', '1.7', '1.8', '1.9', '1.10', '1.11' ]
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-SetIAMPasswordPolicy
              RuntimeParameters:
                AllowUsersToChangePassword: True
                HardExpiry: True
                MaxPasswordAge: 90
                MinimumPasswordLength: 14
                RequireSymbols: True
                RequireNumbers: True
                RequireUppercaseCharacters: True
                RequireLowercaseCharacters: True
                PasswordReusePrevention: 24
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-SetIAMPasswordPolicy'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Established a baseline password policy using the AWSConfigRemediation-SetIAMPasswordPolicy runbook.'
                UpdatedBy: 'SHARR-CIS_1.2.0_1.5'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 1.5/Default
    Condition: Enable15Condition
  CIS21:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.1
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.1

          ## What does this document do?
          Creates a multi-region trail with KMS encryption and enables CloudTrail
          Note: this remediation will create a NEW trail.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [CIS v1.2.0 2.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.1)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.1 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for this remediation
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: ResourceId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: AWSPartition
                Selector: $.Payload.partition
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - '2.1'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-CreateCloudTrailMultiRegionTrail
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateCloudTrailMultiRegionTrail'
                AWSPartition: '{{global:AWS_PARTITION}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Multi-region, encrypted AWS CloudTrail successfully created'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.11'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.1/Default
    Condition: Enable21Condition
  CIS22:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.2
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.2

          ## What does this document do?
          This document enables CloudTrail log file validation.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [CIS v1.2.0 2.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.2)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.2 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCloudTrailLogFileValidation"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: TrailName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:trail/([A-Za-z0-9._-]{3,128})$'
                expected_control_id:
                - '2.2'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableCloudTrailLogFileValidation
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                TrailName: '{{ParseInput.TrailName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled CloudTrail log file validation.'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.2'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.2/Default
    Condition: Enable22Condition
  CIS23:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.3
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.3

          ## What does this document do?
          This document blocks public access to the CloudTrail S3 bucket.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output

          ## Documentation Links
          * [CIS v1.2.0 2.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.3)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.3 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: BucketName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([A-Za-z0-9.-]{3,63})$'
                expected_control_id:
                - '2.3'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false
          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-ConfigureS3BucketPublicAccessBlock
              RuntimeParameters:
                BucketName: '{{ParseInput.BucketName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketPublicAccessBlock'
                RestrictPublicBuckets: true
                BlockPublicAcls: true
                IgnorePublicAcls: true
                BlockPublicPolicy: true

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Disabled public access to CloudTrail logs bucket.'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.3'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.3/Default
    Condition: Enable23Condition
  CIS24:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.4
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.4

          ## What does this document do?
          This document configures CloudTrail to log to CloudWatch Logs.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [CIS v1.2.0 2.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.4)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.4 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableCloudTrailToCloudWatchLogging"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: TrailName
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):cloudtrail:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:trail/([A-Za-z0-9._-]{3,128})$'
                expected_control_id:
                - '2.4'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableCloudTrailToCloudWatchLogging
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                TrailName: '{{ ParseInput.TrailName }}'
                CloudWatchLogsRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CloudTrailToCloudWatchLogs'
                LogGroupName: 'CloudTrail/{{ParseInput.TrailName}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Configured CloudTrail logging to CloudWatch Logs Group CloudTrail/{{ParseInput.TrailName}}'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.4'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.4/Default
    Condition: Enable24Condition
  CIS25:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.5
      Content: |
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.5
          ## What does this document do?
          Enables AWS Config:
          * Turns on recording for all resources.
          * Creates an encrypted bucket for Config logging.
          * Creates a logging bucket for access logs for the config bucket
          * Creates an SNS topic for Config notifications
          * Creates a service-linked role

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Documentation Links
          * [CIS v1.2.0 2.5](https://docs.aws.amazon.com/console/securityhub/standards-cis-2.5/remediation)

        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.5 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for remediations
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - '2.5'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          -
            name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableAWSConfig
              RuntimeParameters:
                SNSTopicName: 'SO0111-SHARR-AWSConfigNotification'
                KMSKeyArn: '{{KMSKeyArn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableAWSConfig'

          -
            name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'AWS Config enabled'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.5'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.5/Default
    Condition: Enable25Condition
  CIS26:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.6
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.6

          ## What does this document do?
          Configures access logging for a CloudTrail S3 bucket.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [CIS v1.2.0 2.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.6)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.6 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: CloudTrailBucket
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):s3:::([a-z0-9.-]{3,63})$'
                expected_control_id:
                - '2.6'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: CreateAccessLoggingBucket
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-CreateAccessLoggingBucket
              RuntimeParameters:
                BucketName: 'so0111-cloudtrailaccesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateAccessLoggingBucket'

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: AWS-ConfigureS3BucketLogging
              RuntimeParameters:
                BucketName: '{{ParseInput.CloudTrailBucket}}'
                GrantedPermission: ['READ']
                GranteeType: ['Group']
                GranteeUri: ['http://acs.amazonaws.com/groups/s3/LogDelivery']
                TargetPrefix: ['{{ParseInput.CloudTrailBucket}}/']
                TargetBucket: ['so0111-cloudtrailaccesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}']
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-ConfigureS3BucketLogging'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Created S3 bucket so0111-cloudtrailaccesslogs-{{global:ACCOUNT_ID}}-{{global:REGION}}
                  for logging access to {{ParseInput.CloudTrailBucket}}'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.6'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.6/Default
    Condition: Enable26Condition
  CIS27:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.7
      Content: |
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.7
          ## What does this document do?
          This document enables SSE KMS encryption for log files using the SHARR remediation KMS CMK
          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
          ## Output Parameters
          * Remediation.Output - Output from UpdateTrail API
          ## Documentation Links
          * [CIS v1.2.0 2.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.7)
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - Remediation.Output
          - ParseInput.AffectedObject
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.7 finding
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        mainSteps:
          -
            name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: TrailArn
                Selector: $.Payload.resource_id
                Type: String
              - Name: TrailRegion
                Selector: $.Payload.resource_region
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: ''
                expected_control_id:
                - '2.7'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          -
            name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableCloudTrailEncryption
              RuntimeParameters:
                TrailRegion: '{{ParseInput.TrailRegion}}'
                TrailArn: '{{ParseInput.TrailArn}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableCloudTrailEncryption'
                KMSKeyArn: '{{KMSKeyArn}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - Id: '{{ParseInput.FindingId}}'
                  ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Encryption enabled on CloudTrail {{ParseInput.TrailArn}}'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.7'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true
      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.7/Default
    Condition: Enable27Condition
  CIS28:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.8
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.8

          ## What does this document do?
          Enables rotation for customer-managed KMS keys.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [CIS v1.2.0 2.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.8)
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.8 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-EnableKeyRotation"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: KMSKeyId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:key/([A-Za-z0-9-]{36})$'
                expected_control_id:
                - '2.8'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: SHARR-EnableKeyRotation
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                KeyId: '{{ParseInput.KMSKeyId}}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled KMS Customer Managed Key rotation for {{ParseInput.KMSKeyId}}'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.8'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.8/Default
    Condition: Enable28Condition
  CIS29:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_2.9
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_2.9

          ## What does this document do?
          Enables VPC Flow Logs for a VPC

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Remediation results

          ## Documentation Links
          * [CIS v1.2.0 2.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-2.9)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 2.9 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: VPC
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:.*:\d{12}:vpc/(vpc-[0-9a-f]{8,17})$'
                expected_control_id:
                - '2.9'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-EnableVPCFlowLogs
              RuntimeParameters:
                VPC: '{{ParseInput.VPC}}'
                RemediationRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs-remediationRole'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-EnableVPCFlowLogs'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Enabled VPC Flow Logs for {{ParseInput.VPC}}'
                UpdatedBy: 'SHARR-CIS_1.2.0_2.9'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 2.9/Default
    Condition: Enable29Condition
  CIS31:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_3.1
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_3.x

          ## What does this document do?
          Remediates the following CIS findings:

          3.1 - Creates a log metric filter and alarm for unauthorized API calls
          3.2 - Creates a log metric filter and alarm for AWS Management Console sign-in without MFA
          3.3 - Creates a log metric filter and alarm for usage of "root" account
          3.4 - Creates a log metric filter and alarm for for IAM policy changes
          3.5 - Creates a log metric filter and alarm for CloudTrail configuration changes
          3.6 - Creates a log metric filter and alarm for AWS Management Console authentication failures
          3.7 - Creates a log metric filter and alarm for disabling or scheduled deletion of customer created CMKs
          3.8 - Creates a log metric filter and alarm for S3 bucket policy changes
          3.9 - Creates a log metric filter and alarm for AWS Config configuration changes
          3.10 - Creates a log metric filter and alarm for security group changes
          3.11 - Creates a log metric filter and alarm for changes to Network Access Control Lists (NACL)
          3.12 - Creates a log metric filter and alarm for changes to network gateways
          3.13 - Creates a log metric filter and alarm for route table changes
          3.14 - Creates a log metric filter and alarm for VPC changes


          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of remediation runbook.

          ## Documentation Links
          [CIS v1.2.0 3.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.1)
          [CIS v1.2.0 3.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.2)
          [CIS v1.2.0 3.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.3)
          [CIS v1.2.0 3.4](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.4)
          [CIS v1.2.0 3.5](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.5)
          [CIS v1.2.0 3.6](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.6)
          [CIS v1.2.0 3.7](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.7)
          [CIS v1.2.0 3.8](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.8)
          [CIS v1.2.0 3.9](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.9)
          [CIS v1.2.0 3.10](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.10)
          [CIS v1.2.0 3.11](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.11)
          [CIS v1.2.0 3.12](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.12)
          [CIS v1.2.0 3.13](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.13)
          [CIS v1.2.0 3.14](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-3.14)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 3.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          LogGroupName:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/Metrics_LogGroupName}}
            description: The name of the Log group to be used to create filters and metric alarms
            allowedPattern: '.*'
          MetricNamespace:
            type: String
            default: 'LogMetrics'
            description: The name of the metric namespace where the metrics will be logged
            allowedPattern: '.*'
          KMSKeyArn:
            type: String
            default: >-
              {{ssm:/Solutions/SO0111/CMK_REMEDIATION_ARN}}
            description: The ARN of the KMS key created by SHARR for remediations
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):kms:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:(?:(?:alias/[A-Za-z0-9/-_])|(?:key/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})))$'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: ControlId
                Selector: $.Payload.control_id
                Type: String
            inputs:
              InputPayload:
                parse_id_pattern: ''
                Finding: '{{Finding}}'
                expected_control_id: [ '3.1', '3.2', '3.3', '3.4', '3.5', '3.6', '3.7', '3.8', '3.9', '3.10', '3.11', '3.12', '3.13','3.14']
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: GetMetricFilterAndAlarmInputValue
            action: 'aws:executeScript'
            outputs:
              - Name: FilterName
                Selector: $.Payload.filter_name
                Type: String
              - Name: FilterPattern
                Selector: $.Payload.filter_pattern
                Type: String
              - Name: MetricName
                Selector: $.Payload.metric_name
                Type: String
              - Name: MetricValue
                Selector: $.Payload.metric_value
                Type: Integer
              - Name: AlarmName
                Selector: $.Payload.alarm_name
                Type: String
              - Name: AlarmDesc
                Selector: $.Payload.alarm_desc
                Type: String
              - Name: AlarmThreshold
                Selector: $.Payload.alarm_threshold
                Type: Integer
            inputs:
              InputPayload:
                ControlId: '{{ParseInput.ControlId}}'
              Runtime: python3.8
              Handler: verify
              Script: |-
                ###############################################################################
                #  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.         #
                #                                                                             #
                #  Licensed under the Apache License Version 2.0 (the "License"). You may not #
                #  use this file except in compliance with the License. A copy of the License #
                #  is located at                                                              #
                #                                                                             #
                #      http://www.apache.org/licenses/LICENSE-2.0/                            #
                #                                                                             #
                #  or in the "license" file accompanying this file. This file is distributed  #
                #  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express #
                #  or implied. See the License for the specific language governing permis-    #
                #  sions and limitations under the License.                                   #
                ###############################################################################
                
                
                CIS_mappings = {
                    "3.1": {
                        "filter_name": "UnauthorizedAPICalls",
                        "filter_pattern": '{($.errorCode="*UnauthorizedOperation") || ($.errorCode="AccessDenied*")}',
                        "metric_name": "UnauthorizedAPICalls",
                        "metric_value": 1,
                        "alarm_name": "UnauthorizedAPICalls",
                        "alarm_desc": "Alarm for UnauthorizedAPICalls > 0",
                        "alarm_threshold": 1
                    },
                    "3.2": {
                        "filter_name": "ConsoleSigninWithoutMFA",
                        "filter_pattern": '{($.eventName="ConsoleLogin") && ($.additionalEventData.MFAUsed !="Yes")}',
                        "metric_name": "ConsoleSigninWithoutMFA",
                        "metric_value": 1,
                        "alarm_name": "ConsoleSigninWithoutMFA",
                        "alarm_desc": "Alarm for ConsoleSigninWithoutMFA > 0",
                        "alarm_threshold": 1
                    },
                    "3.3": {
                        "filter_name": "RootAccountUsage",
                        "filter_pattern": '{$.userIdentity.type="Root" && $.userIdentity.invokedBy NOT EXISTS && $.eventType !="AwsServiceEvent"}',
                        "metric_name": "RootAccountUsage",
                        "metric_value": 1,
                        "alarm_name": "RootAccountUsage",
                        "alarm_desc": "Alarm for RootAccountUsage > 0",
                        "alarm_threshold": 1
                    },
                    "3.4": {
                        "filter_name": "IAMPolicyChanges",
                        "filter_pattern": '{($.eventName=DeleteGroupPolicy) || ($.eventName=DeleteRolePolicy) || ($.eventName=DeleteUserPolicy) || ($.eventName=PutGroupPolicy) || ($.eventName=PutRolePolicy) || ($.eventName=PutUserPolicy) || ($.eventName=CreatePolicy) || ($.eventName=DeletePolicy) || ($.eventName=CreatePolicyVersion) || ($.eventName=DeletePolicyVersion) || ($.eventName=AttachRolePolicy) || ($.eventName=DetachRolePolicy) || ($.eventName=AttachUserPolicy) || ($.eventName=DetachUserPolicy) || ($.eventName=AttachGroupPolicy) || ($.eventName=DetachGroupPolicy)}',
                        "metric_name": "IAMPolicyChanges",
                        "metric_value": 1,
                        "alarm_name": "IAMPolicyChanges",
                        "alarm_desc": "Alarm for IAMPolicyChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.5": {
                        "filter_name": "CloudTrailChanges",
                        "filter_pattern": '{($.eventName=CreateTrail) || ($.eventName=UpdateTrail) || ($.eventName=DeleteTrail) || ($.eventName=StartLogging) || ($.eventName=StopLogging)}',
                        "metric_name": "CloudTrailChanges",
                        "metric_value": 1,
                        "alarm_name": "CloudTrailChanges",
                        "alarm_desc": "Alarm for CloudTrailChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.6": {
                        "filter_name": "ConsoleAuthenticationFailure",
                        "filter_pattern": '{($.eventName=ConsoleLogin) && ($.errorMessage="Failed authentication")}',
                        "metric_name": "ConsoleAuthenticationFailure",
                        "metric_value": 1,
                        "alarm_name": "ConsoleAuthenticationFailure",
                        "alarm_desc": "Alarm for ConsoleAuthenticationFailure > 0",
                        "alarm_threshold": 1
                    },
                    "3.7": {
                        "filter_name": "DisableOrDeleteCMK",
                        "filter_pattern": '{($.eventSource=kms.amazonaws.com) && (($.eventName=DisableKey) || ($.eventName=ScheduleKeyDeletion))}',
                        "metric_name": "DisableOrDeleteCMK",
                        "metric_value": 1,
                        "alarm_name": "DisableOrDeleteCMK",
                        "alarm_desc": "Alarm for DisableOrDeleteCMK > 0",
                        "alarm_threshold": 1
                    },
                    "3.8": {
                        "filter_name": "S3BucketPolicyChanges",
                        "filter_pattern": '{($.eventSource=s3.amazonaws.com) && (($.eventName=PutBucketAcl) || ($.eventName=PutBucketPolicy) || ($.eventName=PutBucketCors) || ($.eventName=PutBucketLifecycle) || ($.eventName=PutBucketReplication) || ($.eventName=DeleteBucketPolicy) || ($.eventName=DeleteBucketCors) || ($.eventName=DeleteBucketLifecycle) || ($.eventName=DeleteBucketReplication))}',
                        "metric_name": "S3BucketPolicyChanges",
                        "metric_value": 1,
                        "alarm_name": "S3BucketPolicyChanges",
                        "alarm_desc": "Alarm for S3BucketPolicyChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.9": {
                        "filter_name": "AWSConfigChanges",
                        "filter_pattern": '{($.eventSource=config.amazonaws.com) && (($.eventName=StopConfigurationRecorder) || ($.eventName=DeleteDeliveryChannel) || ($.eventName=PutDeliveryChannel) || ($.eventName=PutConfigurationRecorder))}',
                        "metric_name": "AWSConfigChanges",
                        "metric_value": 1,
                        "alarm_name": "AWSConfigChanges",
                        "alarm_desc": "Alarm for AWSConfigChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.10": {
                        "filter_name": "SecurityGroupChanges",
                        "filter_pattern": '{($.eventName=AuthorizeSecurityGroupIngress) || ($.eventName=AuthorizeSecurityGroupEgress) || ($.eventName=RevokeSecurityGroupIngress) || ($.eventName=RevokeSecurityGroupEgress) || ($.eventName=CreateSecurityGroup) || ($.eventName=DeleteSecurityGroup)}',
                        "metric_name": "SecurityGroupChanges",
                        "metric_value": 1,
                        "alarm_name": "SecurityGroupChanges",
                        "alarm_desc": "Alarm for SecurityGroupChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.11": {
                        "filter_name": "NetworkACLChanges",
                        "filter_pattern": '{($.eventName=CreateNetworkAcl) || ($.eventName=CreateNetworkAclEntry) || ($.eventName=DeleteNetworkAcl) || ($.eventName=DeleteNetworkAclEntry) || ($.eventName=ReplaceNetworkAclEntry) || ($.eventName=ReplaceNetworkAclAssociation)}',
                        "metric_name": "NetworkACLChanges",
                        "metric_value": 1,
                        "alarm_name": "NetworkACLChanges",
                        "alarm_desc": "Alarm for NetworkACLChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.12": {
                        "filter_name": "NetworkGatewayChanges",
                        "filter_pattern": '{($.eventName=CreateCustomerGateway) || ($.eventName=DeleteCustomerGateway) || ($.eventName=AttachInternetGateway) || ($.eventName=CreateInternetGateway) || ($.eventName=DeleteInternetGateway) || ($.eventName=DetachInternetGateway)}',
                        "metric_name": "NetworkGatewayChanges",
                        "metric_value": 1,
                        "alarm_name": "NetworkGatewayChanges",
                        "alarm_desc": "Alarm for NetworkGatewayChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.13": {
                        "filter_name": "RouteTableChanges",
                        "filter_pattern": '{($.eventName=CreateRoute) || ($.eventName=CreateRouteTable) || ($.eventName=ReplaceRoute) || ($.eventName=ReplaceRouteTableAssociation) || ($.eventName=DeleteRouteTable) || ($.eventName=DeleteRoute) || ($.eventName=DisassociateRouteTable)}',
                        "metric_name": "RouteTableChanges",
                        "metric_value": 1,
                        "alarm_name": "RouteTableChanges",
                        "alarm_desc": "Alarm for RouteTableChanges > 0",
                        "alarm_threshold": 1
                    },
                    "3.14": {
                        "filter_name": "VPCChanges",
                        "filter_pattern": '{($.eventName=CreateVpc) || ($.eventName=DeleteVpc) || ($.eventName=ModifyVpcAttribute) || ($.eventName=AcceptVpcPeeringConnection) || ($.eventName=CreateVpcPeeringConnection) || ($.eventName=DeleteVpcPeeringConnection) || ($.eventName=RejectVpcPeeringConnection) || ($.eventName=AttachClassicLinkVpc) || ($.eventName=DetachClassicLinkVpc) || ($.eventName=DisableVpcClassicLink) || ($.eventName=EnableVpcClassicLink)}',
                        "metric_name": "VPCChanges",
                        "metric_value": 1,
                        "alarm_name": "VPCChanges",
                        "alarm_desc": "Alarm for VPCChanges > 0",
                        "alarm_threshold": 1
                    }
                }
                
                
                def verify(event, context):
                    
                    return CIS_mappings.get(event['ControlId'], None)

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-CreateLogMetricFilterAndAlarm
              RuntimeParameters:
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/SO0111-CreateLogMetricFilterAndAlarm'
                FilterName: '{{ GetMetricFilterAndAlarmInputValue.FilterName }}'
                FilterPattern: '{{ GetMetricFilterAndAlarmInputValue.FilterPattern }}'
                MetricName: '{{ GetMetricFilterAndAlarmInputValue.MetricName }}'
                MetricValue: '{{ GetMetricFilterAndAlarmInputValue.MetricValue }}'
                MetricNamespace: '{{ MetricNamespace }}'
                AlarmName: '{{ GetMetricFilterAndAlarmInputValue.AlarmName }}'
                AlarmDesc: '{{ GetMetricFilterAndAlarmInputValue.AlarmDesc }}'
                AlarmThreshold: '{{ GetMetricFilterAndAlarmInputValue.AlarmThreshold }}'
                LogGroupName: '{{ LogGroupName }}'
                SNSTopicName: 'SO0111-SHARR-LocalAlarmNotification'
                KMSKeyArn: '{{KMSKeyArn}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Added metric filter to the log group and notifications to SNS topic SO0111-SHARR-LocalAlarmNotification.'
                UpdatedBy: 'SHARR-CIS_1.2.0_3.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 3.1/Default
    Condition: Enable31Condition
  CIS41:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_4.1
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_4.1

          ## What does this document do?
          Removes public access from an EC2 Security Group for controls CIS 4.1 and CIS 4.2

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of AWS-DisablePublicAccessForSecurityGroup runbook.

          ## Documentation Links
          * [CIS v1.2.0 4.1](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.1)
          * [CIS v1.2.0 4.2](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.2)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 4.1 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-DisablePublicAccessForSecurityGroup"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-[0-9]):[0-9]{12}:security-group/(sg-[a-f0-9]{8,17})$'
                expected_control_id: ['4.1', '4.2']
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }

          - name: Remediation
            action: 'aws:executeAutomation'
            inputs:
              DocumentName: AWS-DisablePublicAccessForSecurityGroup
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                GroupId: '{{ ParseInput.GroupId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Disabled public access to the security group {{ ParseInput.GroupId }}.'
                UpdatedBy: 'SHARR-CIS_1.2.0_4.1'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 4.1/Default
    Condition: Enable41Condition
  CIS43:
    Type: Custom::UpdatableRunbook
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:SO0111-SHARR-updatableRunbookProvider
      Name: SHARR-CIS_1.2.0_4.3
      Content: |+
        description: |
          ### Document Name - SHARR-CIS_1.2.0_4.3

          ## What does this document do?
          Removes all access from an EC2 Default Security Group to restrict all traffic.

          ## Input Parameters
          * Finding: (Required) Security Hub finding details JSON
          * AutomationAssumeRole: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.

          ## Output Parameters
          * Remediation.Output - Output of remediation runbook.

          ## Documentation Links
          [CIS v1.2.0 4.3](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-cis-controls.html#securityhub-cis-controls-4.3)

        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        outputs:
          - ParseInput.AffectedObject
          - Remediation.Output
        parameters:
          Finding:
            type: StringMap
            description: The input from the Orchestrator Step function for the 4.3 finding
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
            allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
          RemediationRoleName:
            type: String
            default: "SO0111-RemoveVPCDefaultSecurityGroupRules"
            allowedPattern: '^[\w+=,.@-]+'

        mainSteps:
          - name: ParseInput
            action: 'aws:executeScript'
            outputs:
              - Name: GroupId
                Selector: $.Payload.resource_id
                Type: String
              - Name: FindingId
                Selector: $.Payload.finding_id
                Type: String
              - Name: ProductArn
                Selector: $.Payload.product_arn
                Type: String
              - Name: AffectedObject
                Selector: $.Payload.object
                Type: StringMap
              - Name: RemediationRegion
                Selector: $.Payload.resource_region
                Type: String
              - Name: RemediationAccount
                Selector: $.Payload.account_id
                Type: String
            inputs:
              InputPayload:
                Finding: '{{Finding}}'
                parse_id_pattern: '^arn:(?:aws|aws-cn|aws-us-gov):ec2:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:security-group/(sg-[a-f0-9]{8,17})$'
                expected_control_id:
                - '4.3'
              Runtime: python3.8
              Handler: parse_event
              Script: |-
                #!/usr/bin/python
                ## Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
                ## SPDX-License-Identifier: Apache-2.0
                
                import re
                import json
                import boto3
                from botocore.config import Config
                
                def connect_to_config(boto_config):
                    return boto3.client('config', config=boto_config)
                
                def connect_to_ssm(boto_config):
                    return boto3.client('ssm', config=boto_config)
                
                def get_solution_id():
                    return 'SO0111'
                
                def get_solution_version():
                    ssm = connect_to_ssm(
                        Config(
                            retries = {
                                'mode': 'standard'
                            },
                            user_agent_extra = f'AwsSolution/{get_solution_id()}/unknown'
                        )
                    )
                    solution_version = 'unknown'
                    try:
                        ssm_parm_value = ssm.get_parameter(
                            Name=f'/Solutions/{get_solution_id()}/member-version'
                        )['Parameter'].get('Value', 'unknown')
                        solution_version = ssm_parm_value
                    except Exception as e:
                        print(e)
                        print(f'ERROR getting solution version')
                    return solution_version
                
                def get_shortname(long_name):
                    short_name = {
                        'aws-foundational-security-best-practices': 'AFSBP',
                        'cis-aws-foundations-benchmark': 'CIS',
                        'pci-dss': 'PCI'
                    }
                    return short_name.get(long_name, None)
                
                def get_config_rule(rule_name):
                    boto_config = Config(
                        retries = {
                            'mode': 'standard'
                        },
                        user_agent_extra = f'AwsSolution/{get_solution_id()}/{get_solution_version()}'
                    )
                    config_rule = None
                    try:
                        configsvc = connect_to_config(boto_config)
                        config_rule = configsvc.describe_config_rules(
                            ConfigRuleNames=[ rule_name ]
                        ).get('ConfigRules', [])[0]
                    except Exception as e:
                        print(e)
                        exit(f'ERROR getting config rule {rule_name}')
                    return config_rule
                
                class FindingEvent:
                    """
                    Finding object returns the parse fields from an input finding json object
                    """
                    def _get_resource_id(self, parse_id_pattern, resource_index):
                        identifier_raw = self.finding_json['Resources'][0]['Id']
                        self.resource_id = identifier_raw
                        self.resource_id_matches = []
                
                        if parse_id_pattern:
                            identifier_match = re.match(
                                parse_id_pattern,
                                identifier_raw
                            )
                
                            if identifier_match:
                                for group in range(1, len(identifier_match.groups())+1):
                                    self.resource_id_matches.append(identifier_match.group(group))
                                self.resource_id = identifier_match.group(resource_index)
                            else:
                                exit(f'ERROR: Invalid resource Id {identifier_raw}')   
                            return
                
                    def _get_standard_info(self):
                        match_finding_id = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d):\d{12}:subscription/(.*?)/v/(\d+\.\d+\.\d+)/(.*)/finding/(?i:[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12})$',
                            self.finding_json['Id']
                        )
                        if match_finding_id:
                            self.standard_id = get_shortname(match_finding_id.group(1))
                            self.standard_version = match_finding_id.group(2)
                            self.control_id = match_finding_id.group(3)      
                        else:
                            self.valid_finding = False
                            self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]}'
                
                    def _get_aws_config_rule(self):
                        # config_rule_id refers to the AWS Config Rule that produced the finding
                        if "RelatedAWSResources:0/type" in self.finding_json['ProductFields'] and self.finding_json['ProductFields']['RelatedAWSResources:0/type'] == 'AWS::Config::ConfigRule':
                            self.aws_config_rule_id = self.finding_json['ProductFields']['RelatedAWSResources:0/name']
                            self.aws_config_rule = get_config_rule(self.aws_config_rule_id)
                        return
                    
                    def _get_region_from_resource_id(self):
                        check_for_region = re.match(
                            r'^arn:(?:aws|aws-cn|aws-us-gov):[a-zA-Z0-9]+:((?:[a-z]{2}(?:-gov)?-[a-z]+-\d)):.*:.*$',
                            self.finding_json['Resources'][0]['Id']
                        )
                        if check_for_region:
                            self.resource_region = check_for_region.group(1)
                
                    def __init__(self, finding_json, parse_id_pattern, expected_control_id, resource_index):
                        self.valid_finding = True
                        self.resource_region = None
                        self.control_id = None
                        self.aws_config_rule_id = None
                        self.aws_config_rule = {}
                
                        """Populate fields"""
                        # v1.5
                        self.finding_json = finding_json
                        self._get_resource_id(parse_id_pattern, resource_index)     # self.resource_id, self.resource_id_matches
                        self._get_standard_info()                                   # self.standard_id, self.standard_version, self.control_id
                
                        # V1.4
                        self.account_id = self.finding_json.get('AwsAccountId', None)    # deprecate - get Finding.AwsAccountId
                        if not re.match(r'^\d{12}$', self.account_id):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'AwsAccountId is invalid: {self.account_id}'
                        self.finding_id = self.finding_json.get('Id', None)              # deprecate
                        self.product_arn = self.finding_json.get('ProductArn', None)
                        if not re.match(r'^arn:(?:aws|aws-cn|aws-us-gov):securityhub:(?:[a-z]{2}(?:-gov)?-[a-z]+-\d)::product/aws/securityhub$', self.product_arn):
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'ProductArn is invalid: {self.product_arn}'
                        self.details = self.finding_json['Resources'][0].get('Details', {})
                        # Test mode is used with fabricated finding data to tell the 
                        # remediation runbook to run in test more (where supported)
                        # Currently not widely-used and perhaps should be deprecated.
                        self.testmode = bool('testmode' in self.finding_json)
                        self.resource = self.finding_json['Resources'][0]
                        self._get_region_from_resource_id()
                        self._get_aws_config_rule()
                        self.affected_object = {'Type': self.resource['Type'], 'Id': self.resource_id, 'OutputKey': 'Remediation.Output'}
                
                        # Validate control_id   
                        if not self.control_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Finding Id is invalid: {self.finding_json["Id"]} - missing Control Id'
                        elif self.control_id not in expected_control_id:  # ControlId is the expected value
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = f'Control Id from input ({self.control_id}) does not match {str(expected_control_id)}'
                
                        if not self.resource_id:
                            if self.valid_finding:
                                self.valid_finding = False
                                self.invalid_finding_reason = 'Resource Id is missing from the finding json Resources (Id)'
                
                        if not self.valid_finding:
                            # Error message and return error data
                            msg = f'ERROR: {self.invalid_finding_reason}'
                            exit(msg)
                
                    def __str__(self):
                        return json.dumps(self.__dict__)
                
                '''
                MAIN
                '''
                def parse_event(event, context):
                    finding_event = FindingEvent(event['Finding'], event['parse_id_pattern'], event['expected_control_id'], event.get('resource_index', 1))
                  
                    if not finding_event.valid_finding:
                        exit('ERROR: Finding is not valid')
                
                    return {
                        "account_id": finding_event.account_id,
                        "resource_id": finding_event.resource_id, 
                        "finding_id": finding_event.finding_id,         # Deprecate v1.5.0+
                        "control_id": finding_event.control_id,
                        "product_arn": finding_event.product_arn,       # Deprecate v1.5.0+
                        "object": finding_event.affected_object,
                        "matches": finding_event.resource_id_matches,
                        "details": finding_event.details,               # Deprecate v1.5.0+
                        "testmode": finding_event.testmode,             # Deprecate v1.5.0+
                        "resource": finding_event.resource,
                        "resource_region": finding_event.resource_region,
                        "finding": finding_event.finding_json,
                        "aws_config_rule": finding_event.aws_config_rule
                    }
            isEnd: false

          - name: Remediation
            action: 'aws:executeAutomation'
            isEnd: false
            inputs:
              DocumentName: SHARR-RemoveVPCDefaultSecurityGroupRules
              TargetLocations:
                - Accounts: [ '{{ParseInput.RemediationAccount}}' ]
                  Regions: [ '{{ParseInput.RemediationRegion}}' ]
                  ExecutionRoleName: '{{RemediationRoleName}}'
              RuntimeParameters:
                GroupId: '{{ ParseInput.GroupId }}'
                AutomationAssumeRole: 'arn:{{global:AWS_PARTITION}}:iam::{{global:ACCOUNT_ID}}:role/{{RemediationRoleName}}'

          - name: UpdateFinding
            action: 'aws:executeAwsApi'
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
              - Id: '{{ParseInput.FindingId}}'
                ProductArn: '{{ParseInput.ProductArn}}'
              Note:
                Text: 'Removed all access to the default security group {{ ParseInput.GroupId }}.'
                UpdatedBy: 'SHARR-CIS_1.2.0_4.3'
              Workflow:
                Status: RESOLVED
            description: Update finding
            isEnd: true

      DocumentFormat: YAML
      VersionName: v1.50.mybuild
      DocumentType: Automation
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Metadata:
      aws:cdk:path: CIS120MemberStack/CIS 4.3/Default
    Condition: Enable43Condition

